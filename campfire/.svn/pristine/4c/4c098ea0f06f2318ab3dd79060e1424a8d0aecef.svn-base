!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of calc_gradphi in forward (tangent) mode:
!   variations   of useful results: lapphi
!   with respect to varying inputs: vbles
! for now only calculates LapPhi
SUBROUTINE CALC_GRADPHI_D(lapphi, lapphid, vbles, vblesd, dx)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: vblesd(5, 3, 3)
  DOUBLE PRECISION, INTENT(OUT) :: lapphi(3)
  DOUBLE PRECISION, INTENT(OUT) :: lapphid(3)
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil5
  INTEGER :: ip, ii, jj
  INTEGER, SAVE :: n_phases=3
  INTRINSIC RESHAPE
  REAL, DIMENSION(9) :: arg1
  arg1(:) = (/1., 4., 1., 4., -20., 4., 1., 4., 1./)
  stencil = RESHAPE(arg1(:), (/3, 3/))
  arg1(:) = (/0., 1., 0., 1., -4., 1., 0., 1., 0./)
  stencil5 = RESHAPE(arg1(:), (/3, 3/))
  lapphi = 0.
  lapphid = 0.D0
  DO ip=1,n_phases
    DO ii=1,3
      DO jj=1,3
        lapphi(ip) = lapphi(ip) + stencil5(ii, jj)*vbles(ip, ii, jj)/(dx&
&         *dx)
      END DO
    END DO
    lapphid(ip) = lapphid(ip) + stencil5(2, 2)*vblesd(ip, 2,2)/&
         &         (dx*dx)

  END DO
  RETURN
END SUBROUTINE CALC_GRADPHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of entropymixing in forward (tangent) mode:
!   variations   of useful results: entropymixing
!   with respect to varying inputs: c
DOUBLE PRECISION FUNCTION ENTROPYMIXING_D(c, cd, d, entropymixing)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: c
  DOUBLE PRECISION, INTENT(IN) :: cd
  INTEGER, INTENT(IN) :: d
  INTRINSIC LOG
  DOUBLE PRECISION :: entropymixing
! EntropyMixing =0.
! if((1.-c).le.1e-1)then
! if(d.eq.1) EntropyMixing = 2.197224577
! return
! endif
  IF (d .EQ. 1) THEN
    entropymixing_d = (cd*(1.-c)+c*cd)/((1.-c)*c)
    entropymixing = LOG(c/(1.-c))
  ELSE
    entropymixing_d = cd*LOG(c) - cd*LOG(1.-c)
    entropymixing = c*LOG(c) + (1.-c)*LOG(1.-c)
  END IF
END FUNCTION ENTROPYMIXING_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of f_cc in forward (tangent) mode:
!   variations   of useful results: f_cc
!   with respect to varying inputs: x
DOUBLE PRECISION FUNCTION F_CC_D(x, xd, df, f_cc)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: x
  DOUBLE PRECISION, INTENT(IN) :: xd
  INTEGER, INTENT(IN) :: df
  INTRINSIC LOG
  DOUBLE PRECISION :: f_cc
  IF (x*(1.-x) .LE. 0.) THEN
    f_cc = 0.
    f_cc_d = 0.D0
  ELSE IF (df .EQ. 0) THEN
    f_cc_d = (xd*(1.-x)-x*xd)*(LOG(x)-LOG(1.-x)) + x*(1.-x)*(xd/x+xd/(1.&
&     -x))
    f_cc = x*(1.-x)*(LOG(x)-LOG(1.-x))
  ELSE IF (df .EQ. 1) THEN
    f_cc_d = xd/x + xd/(1.-x) - 2.*(xd*LOG(x)+xd) + 2.*(xd*LOG(1.-x)-x*&
&     xd/(1.-x))
    f_cc = LOG(x) - LOG(1. - x) - 2.*x*LOG(x) + 2.*x*LOG(1.-x) + 1.
  ELSE
    f_cc_d = 0.D0
  END IF
END FUNCTION F_CC_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of f_c in forward (tangent) mode:
!   variations   of useful results: f_c
!   with respect to varying inputs: x
DOUBLE PRECISION FUNCTION F_C_D(x, xd, df, f_c)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: x
  DOUBLE PRECISION, INTENT(IN) :: xd
  INTEGER, INTENT(IN) :: df
  DOUBLE PRECISION :: f_c
  f_c = 0.
  IF (df .EQ. 0) THEN
    IF (x*(1-x) .GT. 0.) THEN
      f_c_d = xd*(1.-x) - x*xd
      f_c = x*(1.-x)
    ELSE
      f_c_d = 0.D0
    END IF
  ELSE IF (df .EQ. 1) THEN
    IF (x*(1-x) .GT. 0.) THEN
      f_c_d = -(2.*xd)
      f_c = 1. - 2.*x
    ELSE
      f_c_d = 0.D0
    END IF
  ELSE
    f_c_d = 0.D0
  END IF
END FUNCTION F_C_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of f_phi in forward (tangent) mode:
!   variations   of useful results: f_phi
!   with respect to varying inputs: phi
DOUBLE PRECISION FUNCTION F_PHI_D(phi, phid, i, j, k, f_phi)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi(3)
  DOUBLE PRECISION, INTENT(IN) :: phid(3)
  DOUBLE PRECISION :: G_PHI, s, GG_PHI
  DOUBLE PRECISION :: G_PHI_D, sd, GG_PHI_D
  INTEGER, INTENT(IN) :: i, j, k
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: result3
  DOUBLE PRECISION :: result3d
  DOUBLE PRECISION :: result4
  DOUBLE PRECISION :: result4d
  DOUBLE PRECISION :: result5
  DOUBLE PRECISION :: result5d
  DOUBLE PRECISION :: result6
  DOUBLE PRECISION :: result6d
  DOUBLE PRECISION :: result7
  DOUBLE PRECISION :: result7d
  DOUBLE PRECISION :: result8
  DOUBLE PRECISION :: result8d
  DOUBLE PRECISION :: result9
  DOUBLE PRECISION :: result9d
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d
  DOUBLE PRECISION :: f_phi
  result1d = G_PHI_D(phi(1), phid(1), 0, result1)
  result2d = G_PHI_D(phi(2), phid(2), 0, result2)
  result3d = G_PHI_D(phi(3), phid(3), 0, result3)
  sd = result1d + result2d + result3d
  s = result1 + result2 + result3
  IF (j .EQ. 0) THEN
    f_phi_d = G_PHI_D(phi(i), phid(i), 0, f_phi)
  ELSE IF (k .EQ. 0) THEN
    result1d = GG_PHI_D(phi, phid, i, j, 0, result1)
    result2d = G_PHI_D(phi(i), phid(i), 0, result2)
    result3d = GG_PHI_D(phi, phid, j, j, 0, result3)
    f_phi_d = (result1d*s-result1*sd)/s**2 - ((result2d*result3+result2*&
&     result3d)*s**2-result2*result3*2*s*sd)/(s**2)**2
    f_phi = result1/s - result2*result3/s**2
  ELSE
    result1d = GG_PHI_D(phi, phid, i, j, k, result1)
    result2d = GG_PHI_D(phi, phid, i, j, 0, result2)
    result3d = GG_PHI_D(phi, phid, k, k, 0, result3)
    result4d = GG_PHI_D(phi, phid, i, k, 0, result4)
    result5d = GG_PHI_D(phi, phid, j, j, 0, result5)
    result6d = G_PHI_D(phi(i), phid(i), 0, result6)
    result7d = GG_PHI_D(phi, phid, j, j, k, result7)
    result8d = GG_PHI_D(phi, phid, j, j, 0, result8)
    result9d = G_PHI_D(phi(i), phid(i), 0, result9)
    result10d = GG_PHI_D(phi, phid, k, k, 0, result10)
    f_phi_d = (result1d*s-result1*sd)/s**2 - ((result2d*result3+result2*&
&     result3d)*s**2-result2*result3*2*s*sd)/(s**2)**2 - ((result4d*&
&     result5+result4*result5d)*s**2-result4*result5*2*s*sd)/(s**2)**2 -&
&     ((result6d*result7+result6*result7d)*s**2-result6*result7*2*s*sd)/&
&     (s**2)**2 + (2.*((result8d*result9+result8*result9d)*result10+&
&     result8*result9*result10d)*s**3-2.*result8*result9*result10*3*s**2&
&     *sd)/(s**3)**2
    f_phi = result1/s - result2*result3/s**2 - result4*result5/s**2 - &
&     result6*result7/s**2 + 2.*result8*result9*result10/s**3
  END IF
END FUNCTION F_PHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of freeenergy in forward (tangent) mode:
!   variations   of useful results: freeenergy
!   with respect to varying inputs: t phi phi_dot c_dot c
DOUBLE PRECISION FUNCTION FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, &
& c_dotd, phi_dot, phi_dotd, lp, freeenergy)
  use solution_parameters
  IMPLICIT NONE
  DOUBLE PRECISION :: ta, tb, l_a, l_b, r, mola, molb, rhoa(3), rhob(3)
  DOUBLE PRECISION, INTENT(IN) :: t, c, phi(3), c_dot, phi_dot(3)
  DOUBLE PRECISION, INTENT(IN) :: td, cd, phid(3), c_dotd, phi_dotd(3)
  INTEGER, INTENT(IN) :: lp
  DOUBLE PRECISION, DIMENSION(8) :: v
  DOUBLE PRECISION, DIMENSION(8) :: vd
  DOUBLE PRECISION, DIMENSION(5) :: rk
  DOUBLE PRECISION, DIMENSION(5) :: rkd
  DOUBLE PRECISION :: ha, hb, hr, h(3), F_PHI, ENTROPYMIXING, t_a, &
& e_const
  DOUBLE PRECISION :: had, hbd, hrd, F_PHI_D, ENTROPYMIXING_D
  DOUBLE PRECISION :: tk, T_K, cp, re
  DOUBLE PRECISION :: tkd, T_K_D, cpd, red
  DOUBLE PRECISION, SAVE :: t_eut=456.14
!=(rhoa(1)+rhob(1))/(mola+molb)
  DOUBLE PRECISION, SAVE :: molpervol=54185.
  DOUBLE PRECISION, SAVE :: molpervold
  DOUBLE PRECISION, SAVE :: nu_pb=54730.
  DOUBLE PRECISION, SAVE :: nu_sn=61505.
! double precision :: MolPerVol=1.347708895e5 !debug
  INTEGER :: i, j, tt
! for extra term for PRL paper
  LOGICAL, SAVE :: c_dot_term=.true.
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: freeenergy
!non dimension T to dimensioned Tk for gibbs expansion etc.
  molpervold = nu_sn*cd - nu_pb*cd
  molpervol = nu_pb*(1.-c) + nu_sn*c
  tkd = T_K_D(t, td, tk)
!J/(K mol)
  r = 8.31
! NU = 7.42e-6 !m^3 !taken from phase_8.08/init_eut_Pb_Sn_8.h
! Latent heat
!J/mol 
  l_a = 4773.925095
  l_b = 7029.016991
! Setting Lead diffusivity =1 then implies characteristic length
!delta_a= 1.489764340*10^(-7)*m
! and characteristic time
!tau_a = 9.809908287 10^(-10) s,
! not used: reference only
!!!!!!!!!!!!!!!!!!!!!!!
! rhoa = 10660. !kg/m^3 liquid Lead at melting point
! rhob = 6999.  !              Tin
! ta = 600.61 !Lead
! tb = 505.07 !Tin
!!!!!!!!!!!!!!!!!!!!!!!!
!  mola=.2072     !kg/mol
!  molb= 0.1187  
! rhoa(1)=10660. !liquid Lead kg/m^3
! rhob(1)=6999.  !liquid Tin
! rhoa(2)=11340. !Solid Lead
! rhoa(3)=11340. !The same (for want of a better option)
! rhob(2)=7365.  !Solid Tin (White)
! rhob(3)=7365.  !The same
! t_a=600.61 
! E_const=(R*rhoa(1)*t_a)/mola !~ 2.5 E8 J/m^3
! write(*,*)E_const
! stop
!note: but perhaps Delta T, undercooling is better than t_a
! E_const= 2.56779906e8 !J/m^3 for non-dimensionlising D F/D c
!convert Latent heat yo J/m^3 used in temperature equation.
!This approximation will be superceeded
!Not needed as can work with J/mol in temperature equation
! do i=1,3
! L_a(i)=L_a(i)*rhoa(i)/mola !J/m^3
! L_b(i)=L_b(i)*rhob(i)/molb
! enddo
! J/mol 

  IF (lp .EQ. 0) THEN
!free energy proper
    vd = 0.D0
    CALL GIBBSVECTOR_D(v, vd, tk, tkd, 0)
    rkd = 0.D0
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 0)
    freeenergy = 0.
    freeenergy_d = 0.D0
    DO i=1,3
      ha = 0.
      hb = 0.
      hr = 0.
      had = 0.D0
      hbd = 0.D0
      DO j=1,8
        had = had + hsa(i, j)*vd(j)
        ha = ha + hsa(i, j)*v(j)
        hbd = hbd + hsb(i, j)*vd(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + hsrk(i, 2*j)*tkd*rk(j) + (hsrk(i, 2*j-1)+hsrk(i, 2*j&
&         )*tk)*rkd(j)
        hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
      END DO
!Convert to J/m^3 
!  ha=ha*MolPerVol
!  hb=hb*MolPerVol 
!  hr=hr*MolPerVol
      result1d = F_PHI_D(phi, phid, i, 0, 0, result1)
      freeenergy_d = freeenergy_d + (cd*hb+c*hbd+(1.-c)*had-cd*ha+hrd)*&
&       result1 + (c*hb+(1.-c)*ha+hr)*result1d
      freeenergy = freeenergy + (c*hb+(1.-c)*ha+hr)*result1
    END DO
    result1d = ENTROPYMIXING_D(c, cd, 0, result1)
    freeenergy_d = freeenergy_d + r*(tkd*result1+tk*result1d)
    freeenergy = freeenergy + r*tk*result1
  ELSE IF (lp .LE. n_phases) THEN
!phase = current_var
    freeenergy = 0.
    freeenergy_d = 0.D0
    vd = 0.D0
    rkd = 0.D0
    DO i=1,n_phases
      CALL GIBBSVECTOR_D(v, vd, tk, tkd, 0)
      CALL MIXINGVECTOR_D(rk, rkd, c, cd, 0)
      ha = 0.
      hb = 0.
      hr = 0.
      had = 0.D0
      hbd = 0.D0
      DO j=1,8
        had = had + hsa(i, j)*vd(j)
        ha = ha + hsa(i, j)*v(j)
        hbd = hbd + hsb(i, j)*vd(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + hsrk(i, 2*j)*tkd*rk(j) + (hsrk(i, 2*j-1)+hsrk(i, 2*j&
&         )*tk)*rkd(j)
        hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
      END DO
!Convert to J/m^3 
      had = had*molpervol + ha*molpervold
      ha = ha*molpervol
      hbd = hbd*molpervol + hb*molpervold
      hb = hb*molpervol
      hrd = hrd*molpervol + hr*molpervold
      hr = hr*molpervol
      result1d = F_PHI_D(phi, phid, i, lp, 0, result1)
      freeenergy_d = freeenergy_d + (cd*hb+c*hbd+(1.-c)*had-cd*ha+hrd)*&
&       result1 + (c*hb+(1.-c)*ha+hr)*result1d
      freeenergy = freeenergy + (c*hb+(1.-c)*ha+hr)*result1
    END DO
    RETURN
  ELSE IF (lp .EQ. n_phases + 2) THEN
!Solute
! the below term does not discretise well. So this term is combined
!with the diffusivity (dependent on c and phi_i and T)
!  FreeEnergy = R*Tk*EntropyMixing(c,1) !dimension (J/mol)
!debug
    freeenergy = 0.
    vd = 0.D0
    CALL GIBBSVECTOR_D(v, vd, tk, tkd, 0)
    rkd = 0.D0
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 1)
    freeenergy_d = 0.D0
    DO i=1,n_phases
      ha = 0.
      hb = 0.
      hr = 0.
      had = 0.D0
      hbd = 0.D0
      DO j=1,8
        had = had + hsa(i, j)*vd(j)
        ha = ha + hsa(i, j)*v(j)
        hbd = hbd + hsb(i, j)*vd(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + hsrk(i, 2*j)*tkd*rk(j) + (hsrk(i, 2*j-1)+hsrk(i, 2*j&
&         )*tk)*rkd(j)
        hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
      END DO
! add in other factor and non dimensionalise
! Folch Plapp
      result1d = F_PHI_D(phi, phid, i, 0, 0, result1)
      freeenergy_d = freeenergy_d + (hbd-had+hrd)*result1 + (hb-ha+hr)*&
&       result1d
      freeenergy = freeenergy + (hb-ha+hr)*result1
    END DO
! add in other factor and non dimensionalise
! non-dimensionalise Free energy
    freeenergy_d = freeenergy_d/(r*t_eut)
    freeenergy = freeenergy/(r*t_eut)
  ELSE IF (lp .EQ. n_phases + 1) THEN
!Temperature Keep in J/mol
!  T (d/dT)dF/dphi
    vd = 0.D0
    CALL GIBBSVECTOR_D(v, vd, tk, tkd, 1)
!first derivative of free energy
    rkd = 0.D0
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 0)
    freeenergy = 0.
    freeenergy_d = 0.D0
    DO i=1,n_phases
      ha = 0.
      hb = 0.
      hr = 0.
      had = 0.D0
      hbd = 0.D0
      DO j=1,8
        had = had + hsa(i, j)*vd(j)
        ha = ha + hsa(i, j)*v(j)
        hbd = hbd + hsb(i, j)*vd(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + hsrk(i, 2*j)*rkd(j)
        hr = hr + hsrk(i, 2*j)*rk(j)
      END DO
      DO j=1,n_phases
        result1d = F_PHI_D(phi, phid, i, j, 0, result1)
        freeenergy_d = freeenergy_d + ((tkd*result1+tk*result1d)*phi_dot&
&         (j)+tk*result1*phi_dotd(j))*(c*hb+(1.-c)*ha+hr) + tk*result1*&
&         phi_dot(j)*(cd*hb+c*hbd+(1.-c)*had-cd*ha+hrd)
        freeenergy = freeenergy + tk*(c*hb+(1.-c)*ha+hr)*result1*phi_dot&
&         (j)
      END DO
    END DO
!    pure -dF/dphi term  
    CALL GIBBSVECTOR_D(v, vd, tk, tkd, 0)
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 0)
    DO i=1,n_phases
      ha = 0.
      hb = 0.
      hr = 0.
      had = 0.D0
      hbd = 0.D0
      DO j=1,8
        had = had + hsa(i, j)*vd(j)
        ha = ha + hsa(i, j)*v(j)
        hbd = hbd + hsb(i, j)*vd(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + hsrk(i, 2*j)*tkd*rk(j) + (hsrk(i, 2*j-1)+hsrk(i, 2*j&
&         )*tk)*rkd(j)
        hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
      END DO
      DO j=1,n_phases
        result1d = F_PHI_D(phi, phid, i, j, 0, result1)
        freeenergy_d = freeenergy_d - (cd*hb+c*hbd+(1.-c)*had-cd*ha+hrd)&
&         *result1*phi_dot(j) - (c*hb+(1.-c)*ha+hr)*(result1d*phi_dot(j)&
&         +result1*phi_dotd(j))
        freeenergy = freeenergy - (c*hb+(1.-c)*ha+hr)*result1*phi_dot(j)
      END DO
    END DO
!c_dot_term
    IF (c_dot_term) THEN
!there is a c_dot term see PRL small for large Le
!    T(d/dT)dF/dc =-T (ds/dc) 
      CALL GIBBSVECTOR_D(v, vd, tk, tkd, 1)
      CALL MIXINGVECTOR_D(rk, rkd, c, cd, 1)
      result1d = ENTROPYMIXING_D(c, cd, 1, result1)
      red = r*result1d
      re = r*result1
      DO i=1,n_phases
        ha = 0.
        hb = 0.
        hr = 0.
        had = 0.D0
        hbd = 0.D0
        DO j=1,8
          had = had + hsa(i, j)*vd(j)
          ha = ha + hsa(i, j)*v(j)
          hbd = hbd + hsb(i, j)*vd(j)
          hb = hb + hsb(i, j)*v(j)
        END DO
        hrd = 0.D0
        DO j=1,4
          hrd = hrd + hsrk(i, 2*j)*rkd(j)
          hr = hr + hsrk(i, 2*j)*rk(j)
        END DO
        result1d = F_PHI_D(phi, phid, i, 0, 0, result1)
        freeenergy_d = freeenergy_d + (tkd*c_dot+tk*c_dotd)*(re+(hb-ha+&
&         hr)*result1) + tk*c_dot*(red+(hbd-had+hrd)*result1+(hb-ha+hr)*&
&         result1d)
        freeenergy = freeenergy + tk*(re+(hb-ha+hr)*result1)*c_dot
      END DO
    END IF
!   heat capacity = -T (d/dT) dF/dT
    CALL GIBBSVECTOR_D(v, vd, tk, tkd, 2)
    cp = 0.
    cpd = 0.D0
    DO i=1,n_phases
      ha = 0.
      hb = 0.
      had = 0.D0
      hbd = 0.D0
      DO j=1,8
        had = had + hsa(i, j)*vd(j)
        ha = ha + hsa(i, j)*v(j)
        hbd = hbd + hsb(i, j)*vd(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      result1d = F_PHI_D(phi, phid, i, 0, 0, result1)
      cpd = cpd - (cd*hb+c*hbd+(1.-c)*had-cd*ha)*result1 - (c*hb+(1.-c)*&
&       ha)*result1d
      cp = cp - (c*hb+(1.-c)*ha)*result1
    END DO
    cpd = cpd*tk + cp*tkd
    cp = cp*tk
    freeenergy_d = (freeenergy_d*cp-freeenergy*cpd)/cp**2
    freeenergy = freeenergy/cp
  ELSE
    WRITE(*, *) 'bad current_var'
    STOP
  END IF
END FUNCTION FREEENERGY_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of get_rhs_fi in forward (tangent) mode:
!   variations   of useful results: vbles fi
!   with respect to varying inputs: vbles unk_
!   RW status of diff variables: vbles:in-out fi:out unk_:in
SUBROUTINE GET_RHS_FI_D(vbles, vblesd, dx, fi, fid, mode_1, nunkvbles, &
& dt, dtold, lnblocks, unk_, unk_d,ifid)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: mode_1, nunkvbles, lnblocks
  DOUBLE PRECISION, INTENT(IN) :: dx, dt, dtold, unk_(30)
  DOUBLE PRECISION, INTENT(IN) :: unk_d(30)
  double precision, intent(in) :: ifid
  DOUBLE PRECISION, INTENT(OUT) :: fi(5)
  DOUBLE PRECISION, INTENT(OUT) :: fid(5)
  DOUBLE PRECISION, INTENT(INOUT) :: vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(INOUT) :: vblesd(5, 3, 3)
  DOUBLE PRECISION :: c, t, phi(3), c_dot, phi_dot(3)
  DOUBLE PRECISION :: cd, td, phid(3), c_dotd, phi_dotd(3)
  DOUBLE PRECISION :: phi_rhs(3), dphi_rhs(3), rfactor, rf4, rf5, rf6, s
  DOUBLE PRECISION :: phi_rhsd(3)
  DOUBLE PRECISION :: TEMPERATURERHS, SOLUTERHS_CD, t_k, phi_
  DOUBLE PRECISION :: TEMPERATURERHS_D, SOLUTERHS_D, T_K_D
  LOGICAL :: not_number
  INTEGER :: ip, n, ii, jj, kk

  IF (mode_1 .EQ. 1) THEN
    phi_dotd = 0.D0
    DO ip=1,n_phases
      n = (ip-1)*nunkvbles
      phi_dotd(ip) = (vblesd(ip, 2, 2)-unk_d(n+2))/dt
      phi_dot(ip) = (vbles(ip, 2, 2)-unk_(n+2))/dt
    END DO
    n = (n_phases+1)*nunkvbles
    c_dotd = (vblesd(5, 2, 2)-unk_d(2+n))/dt
    c_dot = (vbles(5, 2, 2)-unk_(2+n))/dt
    phid = 0.D0
  ELSE IF (mode_1 .EQ. 2) THEN
    rfactor = dt/dtold
    rf4 = rfactor*rfactor/(rfactor+1.0)
    rf5 = rfactor + 1.0
    rf6 = (2.0*rfactor+1.0)/(rfactor+1.0)
    phi_dotd = 0.D0
    DO ip=1,n_phases
      n = (ip-1)*nunkvbles
      phi_dotd(ip) = (rf4*unk_d(5+n)-rf5*unk_d(4+n)+rf6*vblesd(ip, 2, 2)&
&       )/dt
      phi_dot(ip) = (rf4*unk_(5+n)-rf5*unk_(4+n)+rf6*vbles(ip, 2, 2))/dt
    END DO
    n = (n_phases+1)*nunkvbles
    c_dotd = (rf4*unk_d(5+n)-rf5*unk_d(4+n)+rf6*vblesd(5, 2, 2))/dt
    c_dot = (rf4*unk_(5+n)-rf5*unk_(4+n)+rf6*vbles(5, 2, 2))/dt
    phid = 0.D0
  ELSE
    WRITE(*, *) 'mode_1 not = 1 or 2'
    STOP
  END IF
  DO ip=1,n_phases
    IF (0d0 .LT. vbles(ip, 2, 2)) THEN
      phid(ip) = vblesd(ip, 2, 2)
      phi(ip) = vbles(ip, 2, 2)
    ELSE
      phid(ip) = 0.D0
      phi(ip) = 0d0
    END IF
  END DO
  DO ip=1,n_phases
    IF (1d0 .GT. phi(ip)/(phi(1)+phi(2)+phi(3))) THEN
      vblesd(ip, 2, 2) = (phid(ip)*(phi(1)+phi(2)+phi(3))-phi(ip)*(phid(&
&       1)+phid(2)+phid(3)))/(phi(1)+phi(2)+phi(3))**2
      vbles(ip, 2, 2) = phi(ip)/(phi(1)+phi(2)+phi(3))
    ELSE
      vblesd(ip, 2, 2) = 0.D0
      vbles(ip, 2, 2) = 1d0
    END IF
  END DO
!debug pcb
  td = vblesd(4, 2, 2)
  t = vbles(4, 2, 2)
  IF (1d0 - 1d-10 .GT. vbles(5, 2, 2)) THEN
    cd = vblesd(5, 2, 2)
    c = vbles(5, 2, 2)
  ELSE
    c = 1d0 - 1d-10
    cd = 0.D0
  END IF
  vblesd(5, 2, 2) = cd
  vbles(5, 2, 2) = c
  if(ifid.le.N_phases)CALL PROJECT_PHASE_D(vbles, vblesd, dx, phi_rhs, phi_rhsd, phi, phid, &
&                c, cd, t, td, c_dot, c_dotd, phi_dot, phi_dotd)
  fid = 0.D0
  DO ip=1,n_phases
    fid(ip) = phi_rhsd(ip)
    fi(ip) = phi_rhs(ip)
  END DO
  fid(n_phases+1) = TEMPERATURERHS_D(vbles, vblesd, dx, c, cd, t, td, &
       &   phi, phid, c_dot, c_dotd, phi_dot, phi_dotd, fi(n_phases+1))
  fid(n_phases+2) = SOLUTERHS_D(vbles, vblesd, dx, c_dot, c_dotd, &
       &   phi_dot, phi_dotd, c, cd, fi(n_phases+2))
END SUBROUTINE GET_RHS_FI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of gg_phi in forward (tangent) mode:
!   variations   of useful results: gg_phi
!   with respect to varying inputs: phi
DOUBLE PRECISION FUNCTION GG_PHI_D(phi, phid, i, j, k, gg_phi)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi(3)
  DOUBLE PRECISION, INTENT(IN) :: phid(3)
  INTEGER, INTENT(IN) :: i, j, k
  DOUBLE PRECISION :: G_PHI
  DOUBLE PRECISION :: G_PHI_D
  DOUBLE PRECISION :: gg_phi
  IF (k .EQ. 0) THEN
    IF (j .EQ. 0) THEN
      gg_phi_d = G_PHI_D(phi(i), phid(i), 0, gg_phi)
    ELSE IF (j .EQ. i) THEN
      gg_phi_d = G_PHI_D(phi(i), phid(i), 1, gg_phi)
    ELSE
      gg_phi = 0.
      gg_phi_d = 0.D0
    END IF
  ELSE IF (k .EQ. i .AND. i .EQ. j) THEN
    gg_phi_d = G_PHI_D(phi(i), phid(i), 2, gg_phi)
  ELSE
    gg_phi = 0.
    gg_phi_d = 0.D0
  END IF
END FUNCTION GG_PHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of gibbsvector in forward (tangent) mode:
!   variations   of useful results: v
!   with respect to varying inputs: t v
SUBROUTINE GIBBSVECTOR_D(v, vd, t, td, d)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(OUT) :: v(8)
  DOUBLE PRECISION, INTENT(OUT) :: vd(8)
  DOUBLE PRECISION, INTENT(IN) :: t
  DOUBLE PRECISION, INTENT(IN) :: td
  INTEGER, INTENT(IN) :: d
  INTRINSIC LOG
  IF (d .EQ. 0) THEN
    vd(1) = 0.D0
    v(1) = 1.0
    vd(2) = td
    v(2) = t
    vd(3) = td*LOG(t) + td
    v(3) = t*LOG(t)
    vd(4) = 2*t*td
    v(4) = t**2
    vd(5) = 3*t**2*td
    v(5) = t**3
    vd(6) = -(td/t**2)
    v(6) = 1./t
    vd(7) = 7*t**6*td
    v(7) = t**7
    vd(8) = -(9*t**8*td/(t**9)**2)
    v(8) = 1.0/t**9
  ELSE IF (d .EQ. 1) THEN
    vd(1) = 0.D0
    v(1) = 0.
    vd(2) = 0.D0
    v(2) = 1.
    vd(3) = td/t
    v(3) = 1. + LOG(t)
    vd(4) = 2.*td
    v(4) = 2.*t
    vd(5) = 3.*2*t*td
    v(5) = 3.*t**2
    vd(6) = 2*t*td/(t**2)**2
    v(6) = -(1./t**2)
    vd(7) = 7.*6*t**5*td
    v(7) = 7.*t**6
    vd(8) = 9.0*10*t**9*td/(t**10)**2
    v(8) = -(9.0/t**10)
  ELSE IF (d .EQ. 2) THEN
    vd(1) = 0.D0
    v(1) = 0.
    vd(2) = 0.D0
    v(2) = 0.
    vd(3) = -(td/t**2)
    v(3) = 1./t
    vd(4) = 0.D0
    v(4) = 2.
    vd(5) = 6.*td
    v(5) = 6.*t
    vd(6) = -(2.*3*t**2*td/(t**3)**2)
    v(6) = 2./t**3
    vd(7) = 42.*5*t**4*td
    v(7) = 42.*t**5
    vd(8) = -(90.*11*t**10*td/(t**11)**2)
    v(8) = 90./t**11
  ELSE
    WRITE(*, *) 'bad diff order in GibbsVector'
    STOP
  END IF
END SUBROUTINE GIBBSVECTOR_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of g_phi in forward (tangent) mode:
!   variations   of useful results: g_phi
!   with respect to varying inputs: phi
! double precision function g_phi(phi,d)
!   double precision, intent (in):: phi
!   integer, intent (in):: d
!   if(d.eq.1)then
!    g_phi = 30.*phi**2*(1.0-phi)**2
!   elseif(d.eq.2)then
!    g_phi = 60.0*phi*(2.0*phi-1.0)*(phi-1.0)
!   else !assume 0
!    g_phi = 6.0*phi**5 - 15.0*phi**4 + 10.0*phi**3
!   endif
! end function g_phi
DOUBLE PRECISION FUNCTION G_PHI_D(phi, phid, d, g_phi)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi
  DOUBLE PRECISION, INTENT(IN) :: phid
  INTEGER, INTENT(IN) :: d
  DOUBLE PRECISION :: g_phi
  IF (d .EQ. 1) THEN
    g_phi_d = 6.*(phid*(1.-phi)-phi*phid)
    g_phi = 6.*phi*(1.-phi)
!    g_phi = 30.*phi**4-60.*phi**3+30.*phi**2
  ELSE IF (d .EQ. 2) THEN
    g_phi_d = -(12.*phid)
    g_phi = 6. - 12.*phi
!    g_phi = 120.*phi**3-180.*phi**2+60.*phi
  ELSE
!assume 0
    g_phi_d = 3.*2*phi*phid - 2.*3*phi**2*phid
    g_phi = 3.*phi**2 - 2.*phi**3
!    g_phi = 6.*phi**5-15.*phi**4+10.*phi**3
  END IF
END FUNCTION G_PHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of gradientenergy in forward (tangent) mode:
!   variations   of useful results: gradientenergy
!   with respect to varying inputs: lapphi vbles
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!  
!!!!  Utilities for phase field stencils in 2-d and 3-d
!!!!  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
DOUBLE PRECISION FUNCTION GRADIENTENERGY_D(lapphi, lapphid, vbles, &
& vblesd, lp, dx, gradientenergy)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: lapphi(3), dx, vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: lapphid(3), vblesd(5, 3, 3)
  INTEGER, INTENT(IN) :: lp
  DOUBLE PRECISION :: phi_x(3), phi_y(3), phi(3), div_q
  DOUBLE PRECISION :: phi_xd(3), phi_yd(3), phid(3)
  INTEGER :: ii
  REAL :: result1
  DOUBLE PRECISION :: gradientenergy

!isotropic                                                                                                
  phid = 0.D0
  phid(1) = vblesd(1, 2, 2)
  phi(1) = vbles(1, 2, 2)
  phid(2) = vblesd(2, 2, 2)
  phi(2) = vbles(2, 2, 2)
  phid(3) = vblesd(3, 2, 2)
  phi(3) = vbles(3, 2, 2)
  phi_xd = 0.D0
!  phi_xd(1) = 0.5*(vblesd(1, 3, 2)-vblesd(1, 1, 2))/dx
  phi_x(1) = (vbles(1, 3, 2)-vbles(1, 1, 2))*0.5/dx
!  phi_xd(2) = 0.5*(vblesd(2, 3, 2)-vblesd(2, 1, 2))/dx
  phi_x(2) = (vbles(2, 3, 2)-vbles(2, 1, 2))*0.5/dx
!  phi_xd(3) = 0.5*(vblesd(3, 3, 2)-vblesd(3, 1, 2))/dx
  phi_x(3) = (vbles(3, 3, 2)-vbles(3, 1, 2))*0.5/dx
  phi_yd = 0.D0
!  phi_yd(1) = 0.5*(vblesd(1, 2, 3)-vblesd(1, 2, 1))/dx
  phi_y(1) = (vbles(1, 2, 3)-vbles(1, 2, 1))*0.5/dx
!  phi_yd(2) = 0.5*(vblesd(2, 2, 3)-vblesd(2, 2, 1))/dx
  phi_y(2) = (vbles(2, 2, 3)-vbles(2, 2, 1))*0.5/dx
!  phi_yd(3) = 0.5*(vblesd(3, 2, 3)-vblesd(3, 2, 1))/dx
  phi_y(3) = (vbles(3, 2, 3)-vbles(3, 2, 1))*0.5/dx
  gradientenergy = 0d0
  gradientenergy_d = 0.D0
  DO ii=1,n_phases
    IF (ii .NE. lp) THEN
      result1 = EPS22(lp, ii)
      gradientenergy_d = gradientenergy_d - result1*(2.*((phid(lp)*phi_x&
&       (ii)+phi(lp)*phi_xd(ii)-phid(ii)*phi_x(lp)-phi(ii)*phi_xd(lp))*&
&       phi_x(ii)+(phi(lp)*phi_x(ii)-phi(ii)*phi_x(lp))*phi_xd(ii)+(phid&
&       (lp)*phi_y(ii)+phi(lp)*phi_yd(ii)-phid(ii)*phi_y(lp)-phi(ii)*&
&       phi_yd(lp))*phi_y(ii)+(phi(lp)*phi_y(ii)-phi(ii)*phi_y(lp))*&
&       phi_yd(ii))-(phid(ii)*lapphi(lp)+phi(ii)*lapphid(lp)-phid(lp)*&
&       lapphi(ii)-phi(lp)*lapphid(ii))*phi(ii)-(phi(ii)*lapphi(lp)-phi(&
&       lp)*lapphi(ii))*phid(ii))
      gradientenergy = gradientenergy - result1*(2.*((phi(lp)*phi_x(ii)-&
&       phi(ii)*phi_x(lp))*phi_x(ii)+(phi(lp)*phi_y(ii)-phi(ii)*phi_y(lp&
&       ))*phi_y(ii))-(phi(ii)*lapphi(lp)-phi(lp)*lapphi(ii))*phi(ii))
    END IF
  END DO
END FUNCTION GRADIENTENERGY_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of mixingvector in forward (tangent) mode:
!   variations   of useful results: rk
!   with respect to varying inputs: rk c
SUBROUTINE MIXINGVECTOR_D(rk, rkd, c, cd, d)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(OUT) :: rk(5)
  DOUBLE PRECISION, INTENT(OUT) :: rkd(5)
  DOUBLE PRECISION, INTENT(IN) :: c
  DOUBLE PRECISION, INTENT(IN) :: cd
  INTEGER, INTENT(IN) :: d
  INTEGER :: i
  IF (d .EQ. 0) THEN
    rkd(1) = cd*(1.-c) - c*cd
    rk(1) = c*(1.-c)
    rkd(2) = rkd(1)*(1.-2.*c) - rk(1)*2.*cd
    rk(2) = rk(1)*(1.-2.*c)
    rkd(3) = rkd(2)*(1.-2.*c) - rk(2)*2.*cd
    rk(3) = rk(2)*(1.-2.*c)
    rkd(4) = rkd(3)*(1.-2.*c) - rk(3)*2.*cd
    rk(4) = rk(3)*(1.-2.*c)
    rkd(5) = rkd(4)*(1.-2.*c) - rk(4)*2.*cd
    rk(5) = rk(4)*(1.-2.*c)
  ELSE IF (d .EQ. 1) THEN
    rkd(1) = -(2.*cd)
    rk(1) = 1. - 2.*c
    rkd(2) = 6.*cd*c + (-6.+6.*c)*cd
    rk(2) = 1. + (-6.+6.*c)*c
    rkd(3) = ((24.-16.*c)*cd-16.*cd*c)*c + (-10.+(24.-16.*c)*c)*cd
    rk(3) = 1. + (-10.+(24.-16.*c)*c)*c
    rkd(4) = ((40.*cd*c+(-80.+40.*c)*cd)*c+(54.+(-80.+40.*c)*c)*cd)*c + &
&     (-14.+(54.+(-80.+40.*c)*c)*c)*cd
    rk(4) = 1. + (-14.+(54.+(-80.+40.*c)*c)*c)*c
    rkd(5) = ((((240.-96.*c)*cd-96.*cd*c)*c+(-224.+(240.-96.*c)*c)*cd)*c&
&     +(96.+(-224.+(240.-96.*c)*c)*c)*cd)*c + (-18.+(96.+(-224.+(240.-&
&     96.*c)*c)*c)*c)*cd
    rk(5) = 1. + (-18.+(96.+(-224.+(240.-96.*c)*c)*c)*c)*c
  ELSE IF (d .EQ. 2) THEN
    rkd(1) = 0.D0
    rk(1) = -2.
    rkd(2) = 12.*cd
    rk(2) = 12.*c - 6.
    rkd(3) = (48.-48.*c)*cd - 48.*cd*c
    rk(3) = -10. + (48.-48.*c)*c
    rkd(4) = (160.*cd*c+(-240.+160.*c)*cd)*c + (108.+(-240.+160.*c)*c)*&
&     cd
    rk(4) = -14. + (108.+(-240.+160.*c)*c)*c
    rkd(5) = (((960.-480.*c)*cd-480.*cd*c)*c+(-672.+(960.-480.*c)*c)*cd)&
&     *c + (192.+(-672.+(960.-480.*c)*c)*c)*cd
    rk(5) = -18. + (192.+(-672.+(960.-480.*c)*c)*c)*c
  ELSE IF (d .EQ. 3) THEN
    rkd(1) = 0.D0
    rk(1) = 0.
    rkd(2) = 0.D0
    rk(2) = 12.
    rkd(3) = -(96.*cd)
    rk(3) = -(96.*c) + 48.
    rkd(4) = 480.*cd*c + (-480.+480.*c)*cd
    rk(4) = 108. + (-480.+480.*c)*c
    rkd(5) = ((2880.-1920.*c)*cd-1920.*cd*c)*c + (-1344.+(2880.-1920.*c)&
&     *c)*cd
    rk(5) = 192. + (-1344.+(2880.-1920.*c)*c)*c
  ELSE
    WRITE(*, *) 'bad diff order in MixingVector'
    STOP
  END IF
END SUBROUTINE MIXINGVECTOR_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of phaserhs in forward (tangent) mode:
!   variations   of useful results: phaserhs
!   with respect to varying inputs: t vbles phi phi_dot c_dot c
DOUBLE PRECISION FUNCTION PHASERHS_D(vbles, vblesd, dx, lp, phi, phid, c&
& , cd, t, td, c_dot, c_dotd, phi_dot, phi_dotd, phaserhs)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
!integer, intent(in)::i,j,k,lb
  DOUBLE PRECISION, INTENT(IN) :: dx, c, t, c_dot, phi_dot(3), phi(3), &
& vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: cd, td, c_dotd, phi_dotd(3), phid(3), &
& vblesd(5, 3, 3)
  INTEGER, INTENT(IN) :: lp
  DOUBLE PRECISION :: lapphi(3)
  DOUBLE PRECISION :: lapphid(3)
  DOUBLE PRECISION :: GRADIENTENERGY_CD, POTENTIAL_CD, FREEENERGY
  DOUBLE PRECISION :: GRADIENTENERGY_D, POTENTIAL_D, FREEENERGY_D
  DOUBLE PRECISION :: rf4, rf5, rf6, rfactor
!m^3/(J s) mobility
  DOUBLE PRECISION, SAVE :: m_a=0.948190
  DOUBLE PRECISION, SAVE :: m_b=0.5680384
  DOUBLE PRECISION, SAVE :: t_a=600.61
  DOUBLE PRECISION, SAVE :: t_b=505.07
  INTEGER :: ii, jj
  DOUBLE PRECISION :: w_a(3, 3)
!s characteristic time
  DOUBLE PRECISION :: m_tilde
  DOUBLE PRECISION :: m_tilded
!decrease to sharpen. This i.c. must increase by similar factor and 
  DOUBLE PRECISION, SAVE :: delta2=4e-18
  DOUBLE PRECISION :: cross_term
  DOUBLE PRECISION, SAVE :: damping=1d0
  INTEGER :: ip, n
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: result3
  DOUBLE PRECISION :: result3d
  DOUBLE PRECISION :: phaserhs

!!!!! Calculate characteristic time and space (squared)
! tau_a=1./(M_a*W_a)
  phaserhs = 0.
! if(lp.eq.3)return
! w_a(1,1)=7e7 ! see notes = 0.07 / delta = 0.07/1e-9 
! = (3/sqrt(2))(sigma_Pb)/delta = (3/sqrt(2))(33.3 ergs/cm^2)/(2e-9m)
  w_a(1, 1) = 7.06d7*0.5094748161
  CALL CALC_GRADPHI_D(lapphi, lapphid, vbles, vblesd, dx)
!assemble and non-dimensionlise phaseRHS 
! see notes Anisotropic2d3d.tex !debug
  m_tilded = -(0.159*cd)
  m_tilde = 1.0 - 0.159*c
!
  result1d = GRADIENTENERGY_D(lapphi, lapphid, vbles, vblesd, lp, dx, &
&   result1)
  result2d = POTENTIAL_D(phi, phid, c, lp, result2)
  result3d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, lp, result3)
  phaserhs_d = m_tilded*(result1-result2*scale_factor**2/lambda**2-&
&   scale_factor**2/lambda*result3/w_a(1, 1)) + m_tilde*(result1d-&
&   scale_factor**2*result2d/lambda**2-scale_factor**2*result3d/lambda/&
&   w_a(1, 1))
  phaserhs = m_tilde*(result1-result2*scale_factor**2/lambda**2-&
&   scale_factor**2/lambda*result3/w_a(1, 1))
END FUNCTION PHASERHS_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of potential in forward (tangent) mode:
!   variations   of useful results: potential
!   with respect to varying inputs: phi
DOUBLE PRECISION FUNCTION POTENTIAL_D(phi, phid, c, lp, potential)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi(3), c
  DOUBLE PRECISION, INTENT(IN) :: phid(3)
  INTEGER, INTENT(IN) :: lp
  INTEGER :: ip, jp
  REAL :: result1
  DOUBLE PRECISION :: potential

  potential = 0.
  IF (lp .LE. n_phases) THEN
    potential_d = 0.D0
    DO ip=1,n_phases
      result1 = EPS22(lp, ip)
      potential_d = potential_d + result1*2d0*(phid(lp)*phi(ip)**2+phi(&
&       lp)*2*phi(ip)*phid(ip))
      potential = potential + result1*2d0*phi(lp)*phi(ip)**2
    END DO
  ELSE
    potential_d = 0.D0
  END IF
  RETURN
END FUNCTION POTENTIAL_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of project_phase in forward (tangent) mode:
!   variations   of useful results: phi_rhs
!   with respect to varying inputs: t vbles phi phi_dot c_dot c
SUBROUTINE PROJECT_PHASE_D(vbles, vblesd, dx, phi_rhs, phi_rhsd, phi, &
& phid, c, cd, t, td, c_dot, c_dotd, phi_dot, phi_dotd)

  use solution_parameters
  IMPLICIT NONE
!integer, intent(in)::df
  DOUBLE PRECISION, INTENT(IN) :: dx, phi(3), c, t, c_dot, phi_dot(3), &
& vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: phid(3), cd, td, c_dotd, phi_dotd(3), &
& vblesd(5, 3, 3)
  DOUBLE PRECISION, INTENT(OUT) :: phi_rhs(3)
  DOUBLE PRECISION, INTENT(OUT) :: phi_rhsd(3)
  DOUBLE PRECISION :: PHASERHS_CD, wk(3)
  DOUBLE PRECISION :: PHASERHS_D, wkd(3)
  INTEGER :: ip, jp, kp, lp, izero
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: i2
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: projector=0.
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: projectord

  INTRINSIC RESHAPE
  REAL, DIMENSION(9) :: arg1
  arg1(:) = (/1., 0., 0., 0., 1., 0., 0., 0., 1./)
  i2 = RESHAPE(arg1(:), (/3, 3/))
  arg1(:) = (/1., 1., 1., 1., 1., 1., 1., 1., 1./)




  phi_rhs = 0.
!assemble Projector
  izero = 0
  DO ip=1,n_phases
    IF (1d0 - phi(ip) .LT. 1d-16) izero = ip
  END DO
  IF (izero .EQ. 0) THEN
! maple generated A
    projectord = 0.D0
    projectord(1, 1) = ((Mobility(1, 2)*(phid(1)*phi(2)+phi(1)*phid(2))*(1-phi(&
&     1))+Mobility(1, 2)*phi(1)*phi(2)*phid(1))*(1-phi(2))/(1-phi(1))**2+Mobility(1, 2&
&     )*phi(1)*phi(2)*phid(2)/(1-phi(1)))/(1-phi(2))**2 + ((Mobility(1, 3)*(&
&     phid(1)*phi(3)+phi(1)*phid(3))*(1-phi(1))+Mobility(1, 3)*phi(1)*phi(3)*&
&     phid(1))*(1-phi(3))/(1-phi(1))**2+Mobility(1, 3)*phi(1)*phi(3)*phid(3)/(1&
&     -phi(1)))/(1-phi(3))**2
    projector(1, 1) = Mobility(1, 2)*phi(1)*phi(2)/(1-phi(1))/(1-phi(2)) + Mobility(1&
&     , 3)*phi(1)*phi(3)/(1-phi(1))/(1-phi(3))
    projectord(2, 1) = -(((Mobility(1, 2)*(phid(1)*phi(2)+phi(1)*phid(2))*(1-&
&     phi(1))+Mobility(1, 2)*phi(1)*phi(2)*phid(1))*(1-phi(2))/(1-phi(1))**2+Mobility(&
&     1, 2)*phi(1)*phi(2)*phid(2)/(1-phi(1)))/(1-phi(2))**2)
    projector(2, 1) = -(Mobility(1, 2)*phi(1)*phi(2)/(1-phi(1))/(1-phi(2)))
    projectord(3, 1) = -(((Mobility(1, 3)*(phid(1)*phi(3)+phi(1)*phid(3))*(1-&
&     phi(1))+Mobility(1, 3)*phi(1)*phi(3)*phid(1))*(1-phi(3))/(1-phi(1))**2+Mobility(&
&     1, 3)*phi(1)*phi(3)*phid(3)/(1-phi(1)))/(1-phi(3))**2)
    projector(3, 1) = -(Mobility(1, 3)*phi(1)*phi(3)/(1-phi(1))/(1-phi(3)))
    projectord(1, 2) = -(((Mobility(1, 2)*(phid(1)*phi(2)+phi(1)*phid(2))*(1-&
&     phi(1))+Mobility(1, 2)*phi(1)*phi(2)*phid(1))*(1-phi(2))/(1-phi(1))**2+Mobility(&
&     1, 2)*phi(1)*phi(2)*phid(2)/(1-phi(1)))/(1-phi(2))**2)
    projector(1, 2) = -(Mobility(1, 2)*phi(1)*phi(2)/(1-phi(1))/(1-phi(2)))
    projectord(2, 2) = ((Mobility(1, 2)*(phid(1)*phi(2)+phi(1)*phid(2))*(1-phi(&
&     1))+Mobility(1, 2)*phi(1)*phi(2)*phid(1))*(1-phi(2))/(1-phi(1))**2+Mobility(1, 2&
&     )*phi(1)*phi(2)*phid(2)/(1-phi(1)))/(1-phi(2))**2 + ((Mobility(2, 3)*(&
&     phid(2)*phi(3)+phi(2)*phid(3))*(1-phi(2))+Mobility(2, 3)*phi(2)*phi(3)*&
&     phid(2))*(1-phi(3))/(1-phi(2))**2+Mobility(2, 3)*phi(2)*phi(3)*phid(3)/(1&
&     -phi(2)))/(1-phi(3))**2
    projector(2, 2) = Mobility(1, 2)*phi(1)*phi(2)/(1-phi(1))/(1-phi(2)) + Mobility(2&
&     , 3)*phi(2)*phi(3)/(1-phi(2))/(1-phi(3))
    projectord(3, 2) = -(((Mobility(2, 3)*(phid(2)*phi(3)+phi(2)*phid(3))*(1-&
&     phi(2))+Mobility(2, 3)*phi(2)*phi(3)*phid(2))*(1-phi(3))/(1-phi(2))**2+Mobility(&
&     2, 3)*phi(2)*phi(3)*phid(3)/(1-phi(2)))/(1-phi(3))**2)
    projector(3, 2) = -(Mobility(2, 3)*phi(2)*phi(3)/(1-phi(2))/(1-phi(3)))
    projectord(1, 3) = -(((Mobility(1, 3)*(phid(1)*phi(3)+phi(1)*phid(3))*(1-&
&     phi(1))+Mobility(1, 3)*phi(1)*phi(3)*phid(1))*(1-phi(3))/(1-phi(1))**2+Mobility(&
&     1, 3)*phi(1)*phi(3)*phid(3)/(1-phi(1)))/(1-phi(3))**2)
    projector(1, 3) = -(Mobility(1, 3)*phi(1)*phi(3)/(1-phi(1))/(1-phi(3)))
    projectord(2, 3) = -(((Mobility(2, 3)*(phid(2)*phi(3)+phi(2)*phid(3))*(1-&
&     phi(2))+Mobility(2, 3)*phi(2)*phi(3)*phid(2))*(1-phi(3))/(1-phi(2))**2+Mobility(&
&     2, 3)*phi(2)*phi(3)*phid(3)/(1-phi(2)))/(1-phi(3))**2)
    projector(2, 3) = -(Mobility(2, 3)*phi(2)*phi(3)/(1-phi(2))/(1-phi(3)))
    projectord(3, 3) = ((Mobility(1, 3)*(phid(1)*phi(3)+phi(1)*phid(3))*(1-phi(&
&     1))+Mobility(1, 3)*phi(1)*phi(3)*phid(1))*(1-phi(3))/(1-phi(1))**2+Mobility(1, 3&
&     )*phi(1)*phi(3)*phid(3)/(1-phi(1)))/(1-phi(3))**2 + ((Mobility(2, 3)*(&
&     phid(2)*phi(3)+phi(2)*phid(3))*(1-phi(2))+Mobility(2, 3)*phi(2)*phi(3)*&
&     phid(2))*(1-phi(3))/(1-phi(2))**2+Mobility(2, 3)*phi(2)*phi(3)*phid(3)/(1&
&     -phi(2)))/(1-phi(3))**2
    projector(3, 3) = Mobility(1, 3)*phi(1)*phi(3)/(1-phi(1))/(1-phi(3)) + Mobility(2&
&     , 3)*phi(2)*phi(3)/(1-phi(2))/(1-phi(3))
    wkd = 0.D0
  ELSE

     Projector(1,1) = MOBILITY(1,2)+MOBILITY(1,3)
     Projector(2,2) = MOBILITY(2,1)+MOBILITY(2,3)
     Projector(3,3) = MOBILITY(3,2)+MOBILITY(3,1)
     Projector(1,2) = -MOBILITY(1,2)
     Projector(1,3) = -MOBILITY(1,3)
     Projector(2,3) = -MOBILITY(2,3)
     Projector(2,1) = -MOBILITY(1,2)
     Projector(3,1) = -MOBILITY(1,3)
     Projector(3,2) = -MOBILITY(2,3)
     projectord = 0.D0
     wkd = 0.D0
  END IF
  DO ip=1,n_phases
    wkd(ip) = PHASERHS_D(vbles, vblesd, dx, ip, phi, phid, c, cd, t, td&
&     , c_dot, c_dotd, phi_dot, phi_dotd, wk(ip))
  END DO
  phi_rhsd = 0.D0
!Project phi_vector
  DO ip=1,n_phases
!q_factor(ip)*tip*dt
    phi_rhsd(ip) = 0.D0
    phi_rhs(ip) = 0.
    DO jp=1,n_phases
      phi_rhsd(ip) = phi_rhsd(ip) + projectord(ip, jp)*wk(jp) + &
&       projector(ip, jp)*wkd(jp)
      phi_rhs(ip) = phi_rhs(ip) + projector(ip, jp)*wk(jp)
    END DO
  END DO
END SUBROUTINE PROJECT_PHASE_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of soluterhs in forward (tangent) mode:
!   variations   of useful results: soluterhs
!   with respect to varying inputs: vbles phi_dot c_dot c_c
!
DOUBLE PRECISION FUNCTION SOLUTERHS_D(vbles, vblesd, dx, c_dot, c_dotd, &
& phi_dot, phi_dotd, c_c, c_cd, soluterhs)
! this uses volume element method. This guarantees conservation of solute. The main source of solute is the variation of free ene
!rgy with phase: d (d F/dc) = ...+ (d^2 F/dc d phi) d phi + ..., which is revealed by a plot of c_dot.
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, c_dot, c_c, vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: c_dotd, c_cd, vblesd(5, 3, 3)
  INTEGER :: ii, jj, ip, ih, jv
  DOUBLE PRECISION :: c, t, phi(3), FREEENERGY, d, phi_dot(3)
  DOUBLE PRECISION :: cd, td, phid(3), FREEENERGY_D, dd, phi_dotd(3)
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil11
  DOUBLE PRECISION, DIMENSION(3), SAVE :: stencil1=(/-.5, 0., .5/)
!Jackson Hunt
  DOUBLE PRECISION, DIMENSION(3), SAVE :: d1=(/6.7e-10, 6.7e-12, 6.7e-12&
&   /)
  DOUBLE PRECISION :: POTENTIAL_CD, d_, d_c, d_cc, F_C, F_CC
  DOUBLE PRECISION :: POTENTIAL_D, d_cd, d_ccd, F_C_D, F_CC_D
! (m^2/s)    characteristic diffusivity delta2/tau=M*eps2(1)
  DOUBLE PRECISION, SAVE :: d_ch=6.7d-10
  INTRINSIC RESHAPE
  REAL, DIMENSION(9) :: arg1
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: soluterhs

  arg1(:) = (/0., 6., 0., 6., -24., 6., 0., 6., 0./)
  stencil11 = RESHAPE(arg1(:), (/3, 3/))
  soluterhs = 0.
!
!if(df.eq.0)then
!x-coordinate transform values
!! Right
  ih = 3
  jv = 2
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.D0
  d_cd = 0.D0
  d_ccd = 0.D0
  DO ip=1,n_phases
    dd = dd + 0.5*d1(ip)*(vblesd(4, 2, 2)*vbles(ip, 2, 2)+(1.&
&     +vbles(4, 2, 2))*vblesd(ip, 2, 2))

    d = d + 0.5*d1(ip)*((1.+vbles(4, ih, jv))*vbles(ip, ih, jv)+(1.+&
&     vbles(4, 2, 2))*vbles(ip, 2, 2))
    result1d = F_C_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_C_D(c_c, c_cd, 0, result2)
    d_cd = d_cd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih, &
&     jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_c = d_c + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
    result1d = F_CC_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_CC_D(c_c, c_cd, 0, result2)
    d_ccd = d_ccd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih&
&     , jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_cc = d_cc + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
  END DO
  cd = vblesd(5, ih, jv)
  c = vbles(5, ih, jv)
  td = vblesd(4, ih, jv)
  t = vbles(4, ih, jv)
  phid = 0.D0
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, ih, jv)
    phi(ip) = vbles(ip, ih, jv)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = d_cd*(result1+result2) + d_c*(result1d+result2d) + dd*c &
&   + d*cd + d_ccd*t + d_cc*td
  soluterhs = soluterhs + d_c*(result1+result2) + d*c + d_cc*t
!  centre
  cd = vblesd(5, 2, 2)
  c = vbles(5, 2, 2)
  td = vblesd(4, 2, 2)
  t = vbles(4, 2, 2)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, 2, 2)
    phi(ip) = vbles(ip, 2, 2)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d - d_cd*(result1+result2) - d_c*(result1d+&
&   result2d) - dd*c - d*cd - d_ccd*t - d_cc*td
  soluterhs = soluterhs - d_c*(result1+result2) - d*c - d_cc*t
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!Left
  ih = 1
  jv = 2
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.D0
  d_cd = 0.D0
  d_ccd = 0.D0
  DO ip=1,n_phases
    dd = dd + 0.5*d1(ip)*(vblesd(4, 2, 2)*vbles(ip, 2, 2)+(1.&
&     +vbles(4, 2, 2))*vblesd(ip, 2, 2))
    d = d + 0.5*d1(ip)*((1.+vbles(4, ih, jv))*vbles(ip, ih, jv)+(1.+&
&     vbles(4, 2, 2))*vbles(ip, 2, 2))
    result1d = F_C_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_C_D(c_c, c_cd, 0, result2)
    d_cd = d_cd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih, &
&     jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_c = d_c + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
    result1d = F_CC_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_CC_D(c_c, c_cd, 0, result2)
    d_ccd = d_ccd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih&
&     , jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_cc = d_cc + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
  END DO
  cd = vblesd(5, ih, jv)
  c = vbles(5, ih, jv)
  td = vblesd(4, ih, jv)
  t = vbles(4, ih, jv)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, ih, jv)
    phi(ip) = vbles(ip, ih, jv)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d + d_cd*(result1+result2) + d_c*(result1d+&
&   result2d) + dd*c + d*cd + d_ccd*t + d_cc*td
  soluterhs = soluterhs + d_c*(result1+result2) + d*c + d_cc*t
!  centre
  cd = vblesd(5, 2, 2)
  c = vbles(5, 2, 2)
  td = vblesd(4, 2, 2)
  t = vbles(4, 2, 2)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, 2, 2)
    phi(ip) = vbles(ip, 2, 2)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d - d_cd*(result1+result2) - d_c*(result1d+&
&   result2d) - dd*c - d*cd - d_ccd*t - d_cc*td
  soluterhs = soluterhs - d_c*(result1+result2) - d*c - d_cc*t
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!up
  ih = 2
  jv = 3
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.D0
  d_cd = 0.D0
  d_ccd = 0.D0
  DO ip=1,n_phases
    dd = dd + 0.5*d1(ip)*(vblesd(4, 2, 2)*vbles(ip, 2, 2)+(1.&
&     +vbles(4, 2, 2))*vblesd(ip, 2, 2))
    d = d + 0.5*d1(ip)*((1.+vbles(4, ih, jv))*vbles(ip, ih, jv)+(1.+&
&     vbles(4, 2, 2))*vbles(ip, 2, 2))
    result1d = F_C_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_C_D(c_c, c_cd, 0, result2)
    d_cd = d_cd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih, &
&     jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_c = d_c + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
    result1d = F_CC_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_CC_D(c_c, c_cd, 0, result2)
    d_ccd = d_ccd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih&
&     , jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_cc = d_cc + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
  END DO
  cd = vblesd(5, ih, jv)
  c = vbles(5, ih, jv)
  td = vblesd(4, ih, jv)
  t = vbles(4, ih, jv)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, ih, jv)
    phi(ip) = vbles(ip, ih, jv)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d + d_cd*(result1+result2) + d_c*(result1d+&
&   result2d) + dd*c + d*cd + d_ccd*t + d_cc*td
  soluterhs = soluterhs + d_c*(result1+result2) + d*c + d_cc*t
!  centre
  cd = vblesd(5, 2, 2)
  c = vbles(5, 2, 2)
  td = vblesd(4, 2, 2)
  t = vbles(4, 2, 2)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, 2, 2)
    phi(ip) = vbles(ip, 2, 2)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d - d_cd*(result1+result2) - d_c*(result1d+&
&   result2d) - dd*c - d*cd - d_ccd*t - d_cc*td
  soluterhs = soluterhs - d_c*(result1+result2) - d*c - d_cc*t
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!down
  ih = 2
  jv = 1
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.D0
  d_cd = 0.D0
  d_ccd = 0.D0
  DO ip=1,n_phases
    dd = dd + 0.5*d1(ip)*(vblesd(4, 2, 2)*vbles(ip, 2, 2)+(1.&
&     +vbles(4, 2, 2))*vblesd(ip, 2, 2))
    d = d + 0.5*d1(ip)*((1.+vbles(4, ih, jv))*vbles(ip, ih, jv)+(1.+&
&     vbles(4, 2, 2))*vbles(ip, 2, 2))
    result1d = F_C_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_C_D(c_c, c_cd, 0, result2)
    d_cd = d_cd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih, &
&     jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_c = d_c + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
    result1d = F_CC_D(vbles(5, ih, jv), vblesd(5, ih, jv), 0, result1)
    result2d = F_CC_D(c_c, c_cd, 0, result2)
    d_ccd = d_ccd + 0.5*d1(ip)*(vblesd(ip, ih, jv)*result1+vbles(ip, ih&
&     , jv)*result1d+vblesd(ip, 2, 2)*result2+vbles(ip, 2, 2)*result2d)
    d_cc = d_cc + 0.5*d1(ip)*(vbles(ip, ih, jv)*result1+vbles(ip, 2, 2)*&
&     result2)
  END DO
  cd = vblesd(5, ih, jv)
  c = vbles(5, ih, jv)
  td = vblesd(4, ih, jv)
  t = vbles(4, ih, jv)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, ih, jv)
    phi(ip) = vbles(ip, ih, jv)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d + d_cd*(result1+result2) + d_c*(result1d+&
&   result2d) + dd*c + d*cd + d_ccd*t + d_cc*td
  soluterhs = soluterhs + d_c*(result1+result2) + d*c + d_cc*t
!  centre
  cd = vblesd(5, 2, 2)
  c = vbles(5, 2, 2)
  td = vblesd(4, 2, 2)
  t = vbles(4, 2, 2)
  DO ip=1,n_phases
    phid(ip) = vblesd(ip, 2, 2)
    phi(ip) = vbles(ip, 2, 2)
  END DO
  result1d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd, &
&   phi_dot, phi_dotd, n_phases + 2, result1)
  result2d = POTENTIAL_D(phi, phid, c, n_phases + 2, result2)
  soluterhs_d = soluterhs_d - d_cd*(result1+result2) - d_c*(result1d+&
&   result2d) - dd*c - d*cd - d_ccd*t - d_cc*td
  soluterhs = soluterhs - d_c*(result1+result2) - d*c - d_cc*t
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  soluterhs_d = soluterhs_d/d_ch/(dx*dx)
  soluterhs = soluterhs/d_ch/(dx*dx)
! SoluteRHS = SoluteRHS+v_mesh*(unk(1+4*nunkvbles,i+1,j,k,lb)-unk(1+4*nunkvbles,i,j,k,lb))/(dx)
!  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  RETURN
END FUNCTION SOLUTERHS_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of temperaturerhs in forward (tangent) mode:
!   variations   of useful results: temperaturerhs
!   with respect to varying inputs: t vbles phi phi_dot c_dot c
DOUBLE PRECISION FUNCTION TEMPERATURERHS_D(vbles, vblesd, dx, c, cd, t, &
& td, phi, phid, c_dot, c_dotd, phi_dot, phi_dotd, temperaturerhs)
  IMPLICIT NONE
!  TemperatureRHS = TemperatureRHS + v_mesh*(unk(1+3*nunkvbles,i+1,j,k,lb)-unk(1+3*nunkvbles,i,j,k,lb))/(dx)
  DOUBLE PRECISION, INTENT(IN) :: dx, c, t, phi(3), c_dot, phi_dot(3), &
& vbles(5, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: cd, td, phid(3), c_dotd, phi_dotd(3), &
& vblesd(5, 3, 3)
!integer, intent (in)::df
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil
  DOUBLE PRECISION, DIMENSION(3), SAVE :: stencil_x=(/-.5, .0, .5/)
!x coordinate
  DOUBLE PRECISION :: FREEENERGY, x, a, xa, dfdc(3, 3)
  DOUBLE PRECISION :: FREEENERGY_D, dfdcd(3, 3)
!29.9758394     !J/mol/K
  DOUBLE PRECISION, SAVE :: cp=28.5
! double precision:: D=2.110795e-5      !m^2/s
!K
  DOUBLE PRECISION, SAVE :: t_eut=456.14
! double precision ::D_c = 2.976894361E-9 !m^2/s characteristic diffusivity
! double precision ::D_ch = 1.126392460619016E-011 !hunt Jackson
!J/(K mol) !hunt Jackson
  DOUBLE PRECISION, SAVE :: d_ch=6.7d-10
  DOUBLE PRECISION, SAVE :: r=8.31
!Jackson Hunt
  DOUBLE PRECISION, DIMENSION(3), SAVE :: d1=(/6.7e-10, 6.7e-12, 6.7e-12&
&   /)
! double precision :: D_tilde = 7090.594237 !dimensionless diffusivity
!dimensionless debug Le=10.
  DOUBLE PRECISION, SAVE :: d_tilde=2630.6602369, d_heat_c
  DOUBLE PRECISION :: d_heat_cd
  DOUBLE PRECISION :: t_, c_, phi_(3)
  DOUBLE PRECISION :: t_d, c_d, phi_d(3)
  LOGICAL, SAVE :: heat_c_term=.true.
  INTEGER :: ii, jj, kk
  INTEGER, SAVE :: n_phases=3
  DOUBLE PRECISION :: ff(3)
  INTRINSIC RESHAPE
  INTRINSIC LOG
  REAL, DIMENSION(9) :: arg1
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: temperaturerhs
  arg1(:) = (/0., 1., 0., 1., -4., 1., 0., 1., 0./)
  stencil = RESHAPE(arg1(:), (/3, 3/))
!  rhoa(1)=10660. !liquid Lead kg/m^3
!  rhoa(2)=11340. !Solid Lead
!  rhoa(3)=11340. !The same (for want of a better option)
!  rhob(1)=6999.  !liquid Tin
!  rhob(2)=7365.  !Solid Tin (White)
!  rhob(3)=7365.  !The same
!  rho=0.25*(11340.+ 7365.+6999.+10660.)!kg/m^3 keep it simple
!  kappa =35.3 !J/(s m)
  temperaturerhs = 0.
  d_tilde = 20.
!    return !delete for isothermal
!J K/mol
  temperaturerhs_d = FREEENERGY_D(c, cd, t, td, phi, phid, c_dot, c_dotd&
&   , phi_dot, phi_dotd, n_phases + 1, temperaturerhs)
!  TemperatureRHS = TemperatureRHS/Cp !means LHS is T_dot only
! heat capacity is in FreeEnergy function now Cp = -T(d/dT)dF/dT
!non dimensional T
  temperaturerhs_d = temperaturerhs_d/t_eut
  temperaturerhs = temperaturerhs/t_eut
  DO ii=1,3
    DO jj=1,3
!  T_=unk(1+N_phases*nunkvbles,i-2+ii,j-2+jj,k,lb)*stencil(ii,jj)
      t_d = stencil(ii, jj)*vblesd(4, ii, jj)
      t_ = vbles(4, ii, jj)*stencil(ii, jj)
      temperaturerhs_d = temperaturerhs_d + d_tilde*t_d/(dx*dx)
      temperaturerhs = temperaturerhs + d_tilde*t_/(dx*dx)
    END DO
  END DO
! replaces c_dot_term an heat_flux_term which does not appear to operate well
  IF (heat_c_term) THEN
    dfdcd = 0.D0
    phi_d = 0.D0
    DO ii=1,3
      DO jj=1,3
!   T_=unk(1+N_phases*nunkvbles,i-2+ii,j-2+jj,k,lb)
        t_d = vblesd(4, ii, jj)
        t_ = vbles(4, ii, jj)
!   c_=unk(1+(N_phases+1)*nunkvbles,i-2+ii,j-2+jj,k,lb)
        c_d = vblesd(5, ii, jj)
        c_ = vbles(5, ii, jj)
        DO kk=1,n_phases
!    phi_(kk)=unk(1+(kk-1)*nunkvbles,i-2+ii,j-2+jj,k,lb)
          phi_d(kk) = vblesd(kk, ii, jj)
          phi_(kk) = vbles(kk, ii, jj)
        END DO
        result1d = FREEENERGY_D(c_, c_d, t_, t_d, phi_, phi_d, c_dot, &
&         c_dotd, phi_dot, phi_dotd, n_phases + 2, result1)
        dfdcd(ii, jj) = t_d*(LOG(c_)-LOG(1.-c_)) + (1.+t_)*(c_d/c_+c_d/(&
&         1.-c_)) + result1d
        dfdc(ii, jj) = (1.+t_)*(LOG(c_)-LOG(1.-c_)) + result1
      END DO
    END DO
    d_heat_c = 0.
    d_heat_cd = 0.D0
    DO ii=1,n_phases
      d_heat_cd = d_heat_cd + d1(ii)*phid(ii)
      d_heat_c = d_heat_c + d1(ii)*phi(ii)
    END DO
    d_heat_cd = ((cd*d_heat_c+c*d_heat_cd)*(1.-c)-c*d_heat_c*cd)/d_ch/(&
&     cp*t_eut)
    d_heat_c = c*(1.-c)*d_heat_c/d_ch/(cp*t_eut)
!  D_heat_c* grad(dfdc) dot grad(dFdc)
    temperaturerhs_d = temperaturerhs_d + (d_heat_cd*((dfdc(3, 2)-dfdc(1&
&     , 2))**2+(dfdc(2, 3)-dfdc(2, 1))**2)+d_heat_c*(2*(dfdc(3, 2)-dfdc(&
&     1, 2))*(dfdcd(3, 2)-dfdcd(1, 2))+2*(dfdc(2, 3)-dfdc(2, 1))*(dfdcd(&
&     2, 3)-dfdcd(2, 1))))/(4.*dx*dx)
    temperaturerhs = temperaturerhs + d_heat_c*((dfdc(3, 2)-dfdc(1, 2))&
&     **2+(dfdc(2, 3)-dfdc(2, 1))**2)/(4.*dx*dx)
  END IF
END FUNCTION TEMPERATURERHS_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of t_k in forward (tangent) mode:
!   variations   of useful results: t_k
!   with respect to varying inputs: t
!T_K converts non-dimensional parameter T to dimensioned T_K(T)
DOUBLE PRECISION FUNCTION T_K_D(t, td, t_k)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: t
  DOUBLE PRECISION, INTENT(IN) :: td
  DOUBLE PRECISION, SAVE :: t_eut=456.14
  DOUBLE PRECISION :: t_k
!Alternate non-dimensionalisation
! double precision T_b,C_b,L_b, 
!  T_b = 505.07
!  C_b = 210.
!  L_b = 7029.
!  T_K = L_b/C_b*T+T_b
  t_eut = 456.14
  t_k_d = t_eut*td
  t_k = t_eut*(1.+t)
END FUNCTION T_K_D
