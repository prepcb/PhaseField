!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of calc_gradphi in forward (tangent) mode:
!   variations   of useful results: lapphi
!   with respect to varying inputs: vbles
! for now only calculates LapPhi
SUBROUTINE CALC_GRADPHI_D(lapphi, lapphid, vbles, vblesd, dx)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, vbles(3, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: vblesd(3, 3, 3)
  DOUBLE PRECISION, INTENT(OUT) :: lapphi
  DOUBLE PRECISION, INTENT(OUT) :: lapphid
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil
  INTEGER :: ii, jj
  INTRINSIC RESHAPE
  REAL, DIMENSION(9) :: arg1
  arg1(:) = (/1., 4., 1., 4., -20., 4., 1., 4., 1./)
  stencil = RESHAPE(arg1(:), (/3, 3/))
  lapphi = 0.0
  lapphid = 0.D0
  DO ii=1,3
    DO jj=1,3
      lapphid = lapphid + stencil(ii, jj)*vblesd(1, ii, jj)
      lapphi = lapphi + stencil(ii, jj)*vbles(1, ii, jj)
    END DO
  END DO
  lapphid = lapphid/6./dx**2
  lapphi = lapphi/6./dx**2
END SUBROUTINE CALC_GRADPHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of cross_term in forward (tangent) mode:
!   variations   of useful results: cross_term phi
!   with respect to varying inputs: vbles c_c
DOUBLE PRECISION FUNCTION CROSS_TERM_D(vbles, vblesd, dx, c_dot, phi_dot&
& , phi, phid, c_c, c_cd, psi, t, cross_term)
! this uses volume element method. This guarantees conservation of solute. The main source of solute is the variation of free ene
!rgy with phase: d (d F/dc) = ...+ (d^2 F/dc d phi) d phi + ..., which is revealed by a plot of c_dot.
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, c_dot, c_c, psi, vbles(3, 3, 3), t
  DOUBLE PRECISION, INTENT(IN) :: c_cd, vblesd(3, 3, 3)
  INTEGER :: ii, jj, ip, ih, jv
  DOUBLE PRECISION :: c, phi, FREEENERGY, d, phi_dot, phi_, phi_tmp
  DOUBLE PRECISION :: cd, phid, FREEENERGY_D, dd
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil11
  DOUBLE PRECISION, DIMENSION(3), SAVE :: stencil1=(/-.5, 0., .5/)
  DOUBLE PRECISION, DIMENSION(3), SAVE :: d1=(/6.70e-10, 6.70e-12, &
&   6.70e-12/)
  DOUBLE PRECISION :: dfdc, potential, lap_c, d_, d_c, d_cc, d_c1, d_cc1&
& , grad_c(2), y0, g_phi, F_C, F_CC
  DOUBLE PRECISION :: POTENTIAL_D, d_cd, d_ccd, G_PHI_D, F_C_D, F_CC_D
! (m^2/s)    characteristic diffusivity delta2/tau=M*eps2(1)
  DOUBLE PRECISION, SAVE :: d_ch=2.83e-10
  DOUBLE PRECISION :: beta1, beta2, m_tilde, phaserhs_c
  DOUBLE PRECISION :: beta1d, PHASERHS_C_D
  INTRINSIC RESHAPE
  REAL, DIMENSION(9) :: arg1
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: cross_term

  arg1(:) = (/0., 6., 0., 6., -24., 6., 0., 6., 0./)
  stencil11 = RESHAPE(arg1(:), (/3, 3/))
  cross_term = 0.
  d_ch = 2.83d-10
!if(df.eq.0)then
!x-coordinate transform values
!! Right
  ih = 3
  jv = 2
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(c_c, c_cd, 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(c_c, c_cd, 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-vbles(&
&   1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd(1, 2, 2&
&   )+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, jv))**2-&
&   vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih, jv))
  beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&   vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = beta1d*(d_c*result1+d*c+d_cc*t) + beta1*(d_cd*result1+&
&   d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term + beta1*(d_c*result1+d*c+d_cc*t)
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d - beta1d*(d_c*result1+d*c+d_cc*t) - beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term - beta1*(d_c*result1+d*c+d_cc*t)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!Left !
  ih = 1
  jv = 2
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(c_c, c_cd, 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(c_c, c_cd, 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-vbles(&
&   1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd(1, 2, 2&
&   )+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, jv))**2-&
&   vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih, jv))
  beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&   vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d + beta1d*(d_c*result1+d*c+d_cc*t) + beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term + beta1*(d_c*result1+d*c+d_cc*t)
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d - beta1d*(d_c*result1+d*c+d_cc*t) - beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term - beta1*(d_c*result1+d*c+d_cc*t)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!up
  ih = 2
  jv = 3
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(c_c, c_cd, 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(c_c, c_cd, 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-vbles(&
&   1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd(1, 2, 2&
&   )+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, jv))**2-&
&   vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih, jv))
  beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&   vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d + beta1d*(d_c*result1+d*c+d_cc*t) + beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term + beta1*(d_c*result1+d*c+d_cc*t)
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d - beta1d*(d_c*result1+d*c+d_cc*t) - beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term - beta1*(d_c*result1+d*c+d_cc*t)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!down
  ih = 2
  jv = 1
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(c_c, c_cd, 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(c_c, c_cd, 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-vbles(&
&   1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd(1, 2, 2&
&   )+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, jv))**2-&
&   vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih, jv))
  beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&   vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d + beta1d*(d_c*result1+d*c+d_cc*t) + beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term + beta1*(d_c*result1+d*c+d_cc*t)
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  cross_term_d = cross_term_d - beta1d*(d_c*result1+d*c+d_cc*t) - beta1*&
&   (d_cd*result1+d_c*result1d+dd*c+d*cd+t*d_ccd)
  cross_term = cross_term - beta1*(d_c*result1+d*c+d_cc*t)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  cross_term_d = cross_term_d/d_ch/(dx*dx)
  cross_term = cross_term/d_ch/(dx*dx)
END FUNCTION CROSS_TERM_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of entropymixing in forward (tangent) mode:
!   variations   of useful results: entropymixing
!   with respect to varying inputs: c
DOUBLE PRECISION FUNCTION ENTROPYMIXING_D(c, cd, d, entropymixing)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: c
  DOUBLE PRECISION, INTENT(IN) :: cd
  INTEGER, INTENT(IN) :: d
  INTRINSIC LOG
  DOUBLE PRECISION :: entropymixing
  IF (d .EQ. 1) THEN
    entropymixing_d = (cd*(1.-c)+c*cd)/((1.-c)*c)
    entropymixing = LOG(c/(1.-c))
  ELSE
    entropymixing_d = cd*LOG(c) - cd*LOG(1.-c)
    entropymixing = c*LOG(c) + (1.-c)*LOG(1.-c)
  END IF
END FUNCTION ENTROPYMIXING_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of f_cc in forward (tangent) mode:
!   variations   of useful results: f_cc
!   with respect to varying inputs: x
DOUBLE PRECISION FUNCTION F_CC_D(x, xd, df, f_cc)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: x
  DOUBLE PRECISION, INTENT(IN) :: xd
  INTEGER, INTENT(IN) :: df
  INTRINSIC LOG
  DOUBLE PRECISION :: f_cc
  IF (x*(1.-x) .LE. 0.) THEN
    f_cc = 0.
    f_cc_d = 0.D0
  ELSE IF (df .EQ. 0) THEN
    f_cc_d = (xd*(1.-x)-x*xd)*(LOG(x)-LOG(1.-x)) + x*(1.-x)*(xd/x+xd/(1.&
&     -x))
    f_cc = x*(1.-x)*(LOG(x)-LOG(1.-x))
  ELSE IF (df .EQ. 1) THEN
    f_cc_d = xd/x + xd/(1.-x) - 2.*(xd*LOG(x)+xd) + 2.*(xd*LOG(1.-x)-x*&
&     xd/(1.-x))
    f_cc = LOG(x) - LOG(1. - x) - 2.*x*LOG(x) + 2.*x*LOG(1.-x) + 1.
  ELSE
    f_cc_d = 0.D0
  END IF
END FUNCTION F_CC_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of f_c in forward (tangent) mode:
!   variations   of useful results: f_c
!   with respect to varying inputs: x
DOUBLE PRECISION FUNCTION F_C_D(x, xd, df, f_c)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: x
  DOUBLE PRECISION, INTENT(IN) :: xd
  INTEGER, INTENT(IN) :: df
  DOUBLE PRECISION :: f_c
  f_c = 0.
  IF (df .EQ. 0) THEN
    IF (x*(1-x) .GT. 0.) THEN
      f_c_d = xd*(1.-x) - x*xd
      f_c = x*(1.-x)
    ELSE
      f_c_d = 0.D0
    END IF
  ELSE IF (df .EQ. 1) THEN
    IF (x*(1-x) .GT. 0.) THEN
      f_c_d = -(2.*xd)
      f_c = 1. - 2.*x
    ELSE
      f_c_d = 0.D0
    END IF
  ELSE
    f_c_d = 0.D0
  END IF
END FUNCTION F_C_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of f_phi in forward (tangent) mode:
!   variations   of useful results: f_phi
!   with respect to varying inputs: phi
DOUBLE PRECISION FUNCTION F_PHI_D(phi, phid, i, j, f_phi)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi
  DOUBLE PRECISION, INTENT(IN) :: phid
  DOUBLE PRECISION :: G_PHI, s, gg_phi
  DOUBLE PRECISION :: G_PHI_D
  INTEGER, INTENT(IN) :: i, j
  DOUBLE PRECISION :: f_phi
  IF (j .EQ. 0) THEN
    IF (i .EQ. 1) THEN
!solute or free energy
      f_phi_d = G_PHI_D(phi, phid, 0, f_phi)
    ELSE
!solute or free energy
      f_phi_d = G_PHI_D(1 - phi, -phid, 0, f_phi)
    END IF
  ELSE IF (i .EQ. 1) THEN
! phase so: d F/(d phi)
    f_phi_d = G_PHI_D(phi, phid, 1, f_phi)
  ELSE
! phase so: d F/(d phi)
    f_phi_d = G_PHI_D(1 - phi, -phid, 1, f_phi)
  END IF
END FUNCTION F_PHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of freeenergy in forward (tangent) mode:
!   variations   of useful results: freeenergy
!   with respect to varying inputs: phi c
DOUBLE PRECISION FUNCTION FREEENERGY_D(c, cd, t, phi, phid, c_dot, &
& phi_dot, lp, freeenergy)
  IMPLICIT NONE
  DOUBLE PRECISION :: ta, tb, l_a, l_b, r, mola, molb, rhoa(3), rhob(3)
  DOUBLE PRECISION, DIMENSION(3, 8) :: hsa, hsb, hsrk
  DOUBLE PRECISION, INTENT(IN) :: t, c, phi, c_dot, phi_dot
  DOUBLE PRECISION, INTENT(IN) :: cd, phid
  INTEGER, INTENT(IN) :: lp
  DOUBLE PRECISION, DIMENSION(8) :: v
  DOUBLE PRECISION, DIMENSION(5) :: rk
  DOUBLE PRECISION, DIMENSION(5) :: rkd
  DOUBLE PRECISION :: ha, hb, hr, h(3), F_PHI, ENTROPYMIXING, t_a, &
& e_const
  DOUBLE PRECISION :: hrd, F_PHI_D, ENTROPYMIXING_D
  DOUBLE PRECISION :: tk, T_K, cp, re
  DOUBLE PRECISION, SAVE :: t_eut=456.14
!=(rhoa(1)+rhob(1))/(mola+molb)
  DOUBLE PRECISION, SAVE :: molpervol=54185.
! double precision :: MolPerVol=1.347708895e5 !debug
  INTEGER :: i, j, tt
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: freeenergy
!non dimension T to dimensioned Tk for gibbs expansion etc.
  tk = T_K(t)
!J/(K mol)
  r = 8.31
! NU = 7.42e-6 !m^3 !taken from phase_8.08/init_eut_Pb_Sn_8.h
! Latent heat
!J/mol 
  l_a = 4773.925095
  l_b = 7029.016991
! Setting Lead diffusivity =1 then implies characteristic length
!delta_a= 1.489764340*10^(-7)*m
! and characteristic time
!tau_a = 9.809908287 10^(-10) s,
! not used: reference only
!!!!!!!!!!!!!!!!!!!!!!!
! rhoa = 10660. !kg/m^3 liquid Lead at melting point
! rhob = 6999.  !              Tin
! ta = 600.61 !Lead
! tb = 505.07 !Tin
!!!!!!!!!!!!!!!!!!!!!!!!
!  mola=.2072     !kg/mol
!  molb= 0.1187  
! rhoa(1)=10660. !liquid Lead kg/m^3
! rhob(1)=6999.  !liquid Tin
! rhoa(2)=11340. !Solid Lead
! rhoa(3)=11340. !The same (for want of a better option)
! rhob(2)=7365.  !Solid Tin (White)
! rhob(3)=7365.  !The same
! t_a=600.61 
! E_const=(R*rhoa(1)*t_a)/mola !~ 2.5 E8 J/m^3
! write(*,*)E_const
! stop
!note: but perhaps Delta T, undercooling is better than t_a
! E_const= 2.56779906e8 !J/m^3 for non-dimensionlising D F/D c
!convert Latent heat yo J/m^3 used in temperature equation.
!This approximation will be superceeded
!Not needed as can work with J/mol in temperature equation
! do i=1,3
! L_a(i)=L_a(i)*rhoa(i)/mola !J/m^3
! L_b(i)=L_b(i)*rhob(i)/molb
! enddo
! J/mol 
  hsa(1, 1) = -2977.961
  hsa(1, 2) = 93.949561
  hsa(1, 3) = -24.5242231
  hsa(1, 4) = -0.365895e-2
  hsa(1, 5) = -0.24395e-6
  hsa(1, 6) = 0.
  hsa(1, 7) = -0.6019e-18
  hsa(1, 8) = 0.
  hsb(1, 1) = 1247.957 + 000.
  hsb(1, 2) = 51.355548
  hsb(1, 3) = -15.961
  hsb(1, 4) = -0.188702e-1
  hsb(1, 5) = 0.3121167e-5
  hsb(1, 6) = -61960.0
  hsb(1, 7) = 0.147031e-17
  hsb(1, 8) = 0.
  hsrk(1, 1) = 6204.5
  hsrk(1, 2) = -.67981
  hsrk(1, 3) = 791.7
  hsrk(1, 4) = -1.5219
  hsrk(1, 5) = 0.
  hsrk(1, 6) = 0.
  hsrk(1, 7) = 0.
  hsrk(1, 8) = 0.
  hsa(2, 1) = -7650.085
  hsa(2, 2) = 101.700244
  hsa(2, 3) = -24.5242231
  hsa(2, 4) = -0.365895e-2
  hsa(2, 5) = -0.24395e-6
  hsa(2, 6) = 0.
  hsa(2, 7) = 0.
  hsa(2, 8) = 0.
  hsb(2, 1) = -345.135
  hsb(2, 2) = 56.983315
  hsb(2, 3) = -15.961
  hsb(2, 4) = -0.188702e-1
  hsb(2, 5) = 0.3121167e-5
  hsb(2, 6) = -61960.0
  hsb(2, 7) = 0.
  hsb(2, 8) = 0.
  hsrk(2, 1) = 7145.3
  hsrk(2, 2) = -2.30237
  hsrk(2, 3) = 0.
  hsrk(2, 4) = 0.
  hsrk(2, 5) = 0.
  hsrk(2, 6) = 0.
  hsrk(2, 7) = 0.
  hsrk(2, 8) = 0.
  hsa(3, 1) = -7161.085
  hsa(3, 2) = 105.220244
  hsa(3, 3) = -24.5242231
  hsa(3, 4) = -0.365895e-2
  hsa(3, 5) = -0.24395e-6
  hsa(3, 6) = 0.
  hsa(3, 7) = 0.
  hsa(3, 8) = 0.
  hsb(3, 1) = -5855.135
  hsb(3, 2) = 65.443315
  hsb(3, 3) = -15.961
  hsb(3, 4) = -0.188702e-1
  hsb(3, 5) = 0.3121167e-5
  hsb(3, 6) = -61960.0
  hsb(3, 7) = 0.
  hsb(3, 8) = 0.
  hsrk(3, 1) = 19700.0
  hsrk(3, 2) = -15.89
  hsrk(3, 3) = 0.
  hsrk(3, 4) = 0.
  hsrk(3, 5) = 0.
  hsrk(3, 6) = 0.
  hsrk(3, 7) = 0.
  hsrk(3, 8) = 0.
  IF (lp .EQ. 0) THEN
!free energy proper
    CALL GIBBSVECTOR(v, tk, 0)
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 0)
    freeenergy = 0.
    freeenergy_d = 0.D0
    DO i=1,2
      ha = 0.
      hb = 0.
      hr = 0.
      DO j=1,8
        ha = ha + hsa(i, j)*v(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rkd(j)
        hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
      END DO
      result1d = F_PHI_D(phi, phid, i, 0, result1)
      freeenergy_d = freeenergy_d + (hb*cd-ha*cd+hrd)*result1 + (c*hb+(&
&       1.-c)*ha+hr)*result1d
      freeenergy = freeenergy + (c*hb+(1.-c)*ha+hr)*result1
    END DO
    result1d = ENTROPYMIXING_D(c, cd, 0, result1)
    freeenergy_d = freeenergy_d + r*tk*result1d
    freeenergy = freeenergy + r*tk*result1
  ELSE IF (lp .EQ. 1) THEN
!phase = current_var
    freeenergy = 0.
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 0)
    i = 1
    CALL GIBBSVECTOR(v, tk, 0)
    ha = 0.
    hb = 0.
    hr = 0.
    DO j=1,8
      ha = ha + hsa(i, j)*v(j)
      hb = hb + hsb(i, j)*v(j)
    END DO
    hrd = 0.D0
    DO j=1,4
      hrd = hrd + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rkd(j)
      hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
    END DO
!Convert to J/m^3 
    result1d = F_PHI_D(phi, phid, i, 1, result1)
    freeenergy_d = molpervol*((hb*cd-ha*cd+hrd)*result1+(c*hb+(1.-c)*ha+&
&     hr)*result1d)
    freeenergy = freeenergy + (c*hb+(1.-c)*ha+hr)*result1*molpervol
    i = 2
    CALL GIBBSVECTOR(v, tk, 0)
    ha = 0.
    hb = 0.
    hr = 0.
    DO j=1,8
      ha = ha + hsa(i, j)*v(j)
      hb = hb + hsb(i, j)*v(j)
    END DO
    hrd = 0.D0
    DO j=1,4
      hrd = hrd + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rkd(j)
      hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
    END DO
!Convert to J/m^3 
    result1d = F_PHI_D(phi, phid, i, 1, result1)
    freeenergy_d = freeenergy_d - molpervol*((hb*cd-ha*cd+hrd)*result1+(&
&     c*hb+(1.-c)*ha+hr)*result1d)
    freeenergy = freeenergy - (c*hb+(1.-c)*ha+hr)*result1*molpervol
    RETURN
  ELSE IF (lp .EQ. 2) THEN
!Solute
! the below term does not discretise well. So this term is combined
!with the diffusivity (dependent on c and phi_i and T)
!  FreeEnergy = R*Tk*EntropyMixing(c,1) !dimension (J/mol)
!debug
    freeenergy = 0.
    CALL GIBBSVECTOR(v, tk, 0)
    CALL MIXINGVECTOR_D(rk, rkd, c, cd, 1)
    freeenergy_d = 0.D0
    DO i=1,2
      ha = 0.
      hb = 0.
      hr = 0.
      DO j=1,8
        ha = ha + hsa(i, j)*v(j)
        hb = hb + hsb(i, j)*v(j)
      END DO
      hrd = 0.D0
      DO j=1,4
        hrd = hrd + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rkd(j)
        hr = hr + (hsrk(i, 2*j-1)+hsrk(i, 2*j)*tk)*rk(j)
      END DO
! add in other factor and non dimensionalise
! Folch Plapp
      result1d = F_PHI_D(phi, phid, i, 0, result1)
      freeenergy_d = freeenergy_d + hrd*result1 + (hb-ha+hr)*result1d
      freeenergy = freeenergy + (hb-ha+hr)*result1
    END DO
! add in other factor and non dimensionalise
! non-dimensionalise Free energy
    freeenergy_d = freeenergy_d/(r*t_eut)
    freeenergy = freeenergy/(r*t_eut)
  ELSE
    WRITE(*, *) 'bad current_variable', lp
    STOP
  END IF
END FUNCTION FREEENERGY_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of get_rhs_fi in forward (tangent) mode:
!   variations   of useful results: phi fi
!   with respect to varying inputs: psi phi c
!   RW status of diff variables: psi:in phi:in-out fi:out c:in
SUBROUTINE GET_RHS_FI_D(vbles, dx, fi, fid, mode_1, nunkvbles, dt, dtold&
& , lnblocks, unk_, phi, phid, c, cd, psi, psid, time, x)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: mode_1, nunkvbles, lnblocks
  DOUBLE PRECISION, INTENT(IN) :: dx, dt, dtold, unk_(18), phi, c, psi, &
& time, x
  DOUBLE PRECISION, INTENT(IN) :: phid, cd, psid
  DOUBLE PRECISION, INTENT(OUT) :: fi(3)
  DOUBLE PRECISION, INTENT(OUT) :: fid(3)
  DOUBLE PRECISION :: t, c_dot, phi_dot, psi_dot
  DOUBLE PRECISION :: phi_rhs, dphi_rhs, rfactor, rf4, rf5, rf6, s
  DOUBLE PRECISION :: phi_rhsd
  DOUBLE PRECISION :: SOLUTERHS_CD, PSIRHS_CD, t_k, phi_, vbles(3, 3, 3)&
& , ff, gg, u1, u2, RAMP
  DOUBLE PRECISION :: SOLUTERHS_D, PSIRHS_D, vblesd(3, 3, 3)
  LOGICAL :: not_number
  INTEGER :: ip, n, ii, jj, kk, i, j, lb

!these three lines are to help tapenade differentiation
  vblesd = 0.D0
  vblesd(1, 2, 2) = phid
  vbles(1, 2, 2) = phi
  vblesd(2, 2, 2) = cd
  vbles(2, 2, 2) = c
  vblesd(3, 2, 2) = psid
  vbles(3, 2, 2) = psi
  IF (mode_1 .EQ. 1) THEN
    phi_dot = (phi-unk_(2))/dt
    c_dot = (c-unk_(2+nunkvbles))/dt
  ELSE IF (mode_1 .EQ. 2) THEN
    rfactor = dt/dtold
    rf4 = rfactor*rfactor/(rfactor+1.0)
    rf5 = rfactor + 1.0
    rf6 = (2.0*rfactor+1.0)/(rfactor+1.0)
    phi_dot = (rf4*unk_(5)-rf5*unk_(4)+rf6*phi)/dt
    c_dot = (rf4*unk_(5+nunkvbles)-rf5*unk_(4+nunkvbles)+rf6*c)/dt
  ELSE
    WRITE(*, *) 'mode_1 not = 1 or 2', mode_1
    STOP
  END IF
  IF (0d0 .LT. phi) THEN
    vblesd(1, 2, 2) = phid
    vbles(1, 2, 2) = phi
  ELSE
    vblesd(1, 2, 2) = 0.D0
    vbles(1, 2, 2) = 0d0
  END IF
  IF (1d0 .GT. phi) THEN
    vblesd(1, 2, 2) = phid
    vbles(1, 2, 2) = phi
  ELSE
    vblesd(1, 2, 2) = 0.D0
    vbles(1, 2, 2) = 1d0
  END IF
T = delta
!T = min(delta,delta - (time - 3d2)*3d-2/3d3)
!T = ramp(x+4d1-0.04*time)




  CALL PROJECT_PHASE_D(vbles, vblesd, dx, phi_rhs, phi_rhsd, phi, phid, &
&                c, cd, psi, t, c_dot, phi_dot)
  fid = 0.D0
  fid(1) = phi_rhsd
  fi(1) = phi_rhs
  fid(2) = SOLUTERHS_D(vbles, vblesd, dx, c_dot, phi_dot, t, fi(2))
  fid(3) = PSIRHS_D(phi, phid, c, cd, t, c_dot, phi_dot, vbles, vblesd, &
&   dx, unk_, mode_1, dt, dtold, nunkvbles, fi(3))
END SUBROUTINE GET_RHS_FI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of g_phi in forward (tangent) mode:
!   variations   of useful results: g_phi
!   with respect to varying inputs: phi
DOUBLE PRECISION FUNCTION G_PHI_D(phi, phid, d, g_phi)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi
  DOUBLE PRECISION, INTENT(IN) :: phid
  INTEGER, INTENT(IN) :: d
  DOUBLE PRECISION :: g_phi
  IF (d .EQ. 1) THEN
    g_phi_d = 6.*(phid*(1.-phi)-phi*phid)
    g_phi = 6.*phi*(1.-phi)
!    g_phi = 30.*phi**4-60.*phi**3+30.*phi**2
  ELSE
!assume 0
    g_phi_d = 3.*2*phi*phid - 2.*3*phi**2*phid
    g_phi = 3.*phi**2 - 2.*phi**3
!    g_phi = 6.*phi**5-15.*phi**4+10.*phi**3
  END IF
END FUNCTION G_PHI_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of mixingvector in forward (tangent) mode:
!   variations   of useful results: rk
!   with respect to varying inputs: c
SUBROUTINE MIXINGVECTOR_D(rk, rkd, c, cd, d)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(OUT) :: rk(5)
  DOUBLE PRECISION, INTENT(OUT) :: rkd(5)
  DOUBLE PRECISION, INTENT(IN) :: c
  DOUBLE PRECISION, INTENT(IN) :: cd
  INTEGER, INTENT(IN) :: d
  INTEGER :: i
  IF (d .EQ. 0) THEN
    rkd = 0.D0
    rkd(1) = cd*(1.-c) - c*cd
    rk(1) = c*(1.-c)
    rkd(2) = rkd(1)*(1.-2.*c) - rk(1)*2.*cd
    rk(2) = rk(1)*(1.-2.*c)
    rkd(3) = rkd(2)*(1.-2.*c) - rk(2)*2.*cd
    rk(3) = rk(2)*(1.-2.*c)
    rkd(4) = rkd(3)*(1.-2.*c) - rk(3)*2.*cd
    rk(4) = rk(3)*(1.-2.*c)
    rkd(5) = rkd(4)*(1.-2.*c) - rk(4)*2.*cd
    rk(5) = rk(4)*(1.-2.*c)
  ELSE IF (d .EQ. 1) THEN
    rkd = 0.D0
    rkd(1) = -(2.*cd)
    rk(1) = 1. - 2.*c
    rkd(2) = 6.*cd*c + (-6.+6.*c)*cd
    rk(2) = 1. + (-6.+6.*c)*c
    rkd(3) = ((24.-16.*c)*cd-16.*cd*c)*c + (-10.+(24.-16.*c)*c)*cd
    rk(3) = 1. + (-10.+(24.-16.*c)*c)*c
    rkd(4) = ((40.*cd*c+(-80.+40.*c)*cd)*c+(54.+(-80.+40.*c)*c)*cd)*c + &
&     (-14.+(54.+(-80.+40.*c)*c)*c)*cd
    rk(4) = 1. + (-14.+(54.+(-80.+40.*c)*c)*c)*c
    rkd(5) = ((((240.-96.*c)*cd-96.*cd*c)*c+(-224.+(240.-96.*c)*c)*cd)*c&
&     +(96.+(-224.+(240.-96.*c)*c)*c)*cd)*c + (-18.+(96.+(-224.+(240.-&
&     96.*c)*c)*c)*c)*cd
    rk(5) = 1. + (-18.+(96.+(-224.+(240.-96.*c)*c)*c)*c)*c
  ELSE IF (d .EQ. 2) THEN
    rk(1) = -2.
    rkd = 0.D0
    rkd(2) = 12.*cd
    rk(2) = 12.*c - 6.
    rkd(3) = (48.-48.*c)*cd - 48.*cd*c
    rk(3) = -10. + (48.-48.*c)*c
    rkd(4) = (160.*cd*c+(-240.+160.*c)*cd)*c + (108.+(-240.+160.*c)*c)*&
&     cd
    rk(4) = -14. + (108.+(-240.+160.*c)*c)*c
    rkd(5) = (((960.-480.*c)*cd-480.*cd*c)*c+(-672.+(960.-480.*c)*c)*cd)&
&     *c + (192.+(-672.+(960.-480.*c)*c)*c)*cd
    rk(5) = -18. + (192.+(-672.+(960.-480.*c)*c)*c)*c
  ELSE IF (d .EQ. 3) THEN
    rk(1) = 0.
    rk(2) = 12.
    rkd = 0.D0
    rkd(3) = -(96.*cd)
    rk(3) = -(96.*c) + 48.
    rkd(4) = 480.*cd*c + (-480.+480.*c)*cd
    rk(4) = 108. + (-480.+480.*c)*c
    rkd(5) = ((2880.-1920.*c)*cd-1920.*cd*c)*c + (-1344.+(2880.-1920.*c)&
&     *c)*cd
    rk(5) = 192. + (-1344.+(2880.-1920.*c)*c)*c
  ELSE
    WRITE(*, *) 'bad diff order in MixingVector'
    STOP
  END IF
END SUBROUTINE MIXINGVECTOR_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of phaserhs_c in forward (tangent) mode:
!   variations   of useful results: phaserhs_c
!   with respect to varying inputs: vbles phi c
DOUBLE PRECISION FUNCTION PHASERHS_C_D(phi, phid, c, cd, t, c_dot, &
& phi_dot, vbles, vblesd, dx, phaserhs_c)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: c, t, c_dot, phi_dot, phi, vbles(3, 3&
& , 3), dx
  DOUBLE PRECISION, INTENT(IN) :: cd, phid, vblesd(3, 3, 3)
  DOUBLE PRECISION :: POTENTIAL, FREEENERGY, ge, dd_fi, &
& GRADIENTENERGY, lapphi
  DOUBLE PRECISION :: POTENTIAL_D, FREEENERGY_D, GRADIENTENERGY_D, &
& lapphid
  DOUBLE PRECISION :: w_a(3, 3)
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: result3
  DOUBLE PRECISION :: result3d
  DOUBLE PRECISION :: phaserhs_c

! see notes = 0.07 / delta = 0.07/1e-9 
  w_a(1, 1) = 7e7
!
!assemble and non-dimensionlise phaseRHS 
!phaseRHS_c is (D F/D phi)/W_a(1,1)
  CALL CALC_GRADPHI_D(lapphi, lapphid, vbles, vblesd, dx)
  result1 = GRADIENTENERGY(lapphi,  vbles, dx)
  result1d = GRADIENTENERGY_D(vbles, dx)
  result2d = POTENTIAL_D(phi, phid, c, 1, result2)
  result3d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 1, &
&   result3)
  phaserhs_c_d = result2d/lambda - lambda*result1d + result3d/w_a(1, 1)
  phaserhs_c = -(lambda*result1) + result2/lambda + result3/w_a(1, 1)
END FUNCTION PHASERHS_C_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of phaserhs in forward (tangent) mode:
!   variations   of useful results: phi phaserhs
!   with respect to varying inputs: vbles phi c
DOUBLE PRECISION FUNCTION PHASERHS_D(vbles, vblesd, dx, phi, phid, c, cd&
& , psi, t, c_dot, phi_dot, phaserhs)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, c, t, c_dot, phi_dot, phi, psi, &
& vbles(3, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: cd, phid, vblesd(3, 3, 3)
  DOUBLE PRECISION :: lapphi
  DOUBLE PRECISION :: lapphid
  DOUBLE PRECISION :: GRADIENTENERGY, POTENTIAL, FREEENERGY, ge, &
& dd_fi
  DOUBLE PRECISION :: GRADIENTENERGY_D, POTENTIAL_D, FREEENERGY_D
  DOUBLE PRECISION :: rf4, rf5, rf6, rfactor
!m^3/(J s) mobility
  DOUBLE PRECISION, SAVE :: m_a=0.948190
  DOUBLE PRECISION, SAVE :: m_b=0.5680384
  DOUBLE PRECISION, SAVE :: t_a=600.61
  DOUBLE PRECISION, SAVE :: t_b=505.07
  INTEGER :: ii, jj
  DOUBLE PRECISION :: w_a(3, 3), beta_, CROSS_TERM_CD
  DOUBLE PRECISION :: CROSS_TERM_D
!s characteristic time
  DOUBLE PRECISION :: m_tilde
  DOUBLE PRECISION :: m_tilded
!decrease to sharpen. This i.c. must increase by similar factor and 
  DOUBLE PRECISION, SAVE :: delta2=4e-18
  INTEGER :: ip, n
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: result3
  DOUBLE PRECISION :: result3d
  DOUBLE PRECISION :: phaserhs


!!!!! Calculate characteristic time and space (squared)
! tau_a=1./(M_a*W_a)
  phaserhs = 0.
! see notes = 0.07 / delta = 0.07/1e-9 
  w_a(1, 1) = 7e7
  CALL CALC_GRADPHI_D(lapphi, lapphid, vbles, vblesd, dx)
!assemble and non-dimensionlise phaseRHS 
! see notes Anisotropic2d3d.tex !!
  m_tilded = -(0.159*cd)
  m_tilde = 1.0 - 0.159*c
!  M_tilde = M_tilde*(1+beta*alpha*lambda)
!

  result1 = GRADIENTENERGY(lapphi,  vbles, dx)
  result1d = GRADIENTENERGY_D(vbles, dx)
  result2d = POTENTIAL_D(phi, phid, c, 1, result2)
  result3d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 1, &
&   result3)
  phaserhs_d = m_tilded*(result1-result2/lambda**2-result3/lambda/w_a(1&
&   , 1)) + m_tilde*(result1d-result2d/lambda**2-result3d/lambda/w_a(1, &
&   1))
  phaserhs = m_tilde*(result1-result2/lambda**2-result3/lambda/w_a(1, 1)&
&   )
!
  IF (beta .GT. 1d-6) THEN
    result1d = CROSS_TERM_D(vbles, vblesd, dx, c_dot, phi_dot, phi, phid&
&     , c, cd, psi, t, result1)
    phaserhs_d = phaserhs_d - result1d
    phaserhs = phaserhs - result1
  END IF
END FUNCTION PHASERHS_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of potential in forward (tangent) mode:
!   variations   of useful results: potential
!   with respect to varying inputs: phi
DOUBLE PRECISION FUNCTION POTENTIAL_D(phi, phid, c, lp, potential)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: phi, c
  DOUBLE PRECISION, INTENT(IN) :: phid
  INTEGER, INTENT(IN) :: lp
  DOUBLE PRECISION, DIMENSION(3, 3) :: sigma_a, sigma_b
  DOUBLE PRECISION, DIMENSION(3) :: wa, wb
  DOUBLE PRECISION, DIMENSION(3, 3) :: beta_a, beta_b, delta_a, delta_b
! double precision ::R = 8.31,T_eut=456.14,MolPerVol= 54185.3329242099
!=1/(R*T_eut*MolPerVol)
  DOUBLE PRECISION, SAVE :: volperjoule=4.87e-009
  DOUBLE PRECISION :: potential
  potential = 0d0
  IF (lp .EQ. 1) THEN
    potential_d = 4*3*phi**2*phid - 6*2*phi*phid + 2*phid
    potential = 4*phi**3 - 6*phi**2 + 2*phi
  ELSE
    potential_d = 0.D0
  END IF
END FUNCTION POTENTIAL_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of project_phase in forward (tangent) mode:
!   variations   of useful results: phi_rhs phi
!   with respect to varying inputs: vbles phi c
!
SUBROUTINE PROJECT_PHASE_D(vbles, vblesd, dx, phi_rhs, phi_rhsd, phi, &
& phid, c, cd, psi, t, c_dot, phi_dot)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, phi, c, psi, t, c_dot, phi_dot, &
& vbles(3, 3, 3)
  DOUBLE PRECISION, INTENT(IN) :: phid, cd, vblesd(3, 3, 3)
  DOUBLE PRECISION, INTENT(OUT) :: phi_rhs
  DOUBLE PRECISION, INTENT(OUT) :: phi_rhsd
  DOUBLE PRECISION :: PHASERHS_CD
  DOUBLE PRECISION :: PHASERHS_D
  phi_rhsd = PHASERHS_D(vbles, vblesd, dx, phi, phid, c, cd, psi, t, &
&   c_dot, phi_dot, phi_rhs)
END SUBROUTINE PROJECT_PHASE_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of psirhs in forward (tangent) mode:
!   variations   of useful results: psirhs
!   with respect to varying inputs: vbles phi c
DOUBLE PRECISION FUNCTION PSIRHS_D(phi, phid, c, cd, t, c_dot, phi_dot, &
& vbles, vblesd, dx, unk_, mode_1, dt, dtold, nunkvbles, psirhs)
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, vbles(3, 3, 3), phi, c, t, c_dot, &
& phi_dot, unk_(18), dt, dtold
  DOUBLE PRECISION, INTENT(IN) :: vblesd(3, 3, 3), phid, cd
  INTEGER, INTENT(IN) :: mode_1, nunkvbles
  DOUBLE PRECISION :: dfdphi, PHASERHS_C_CD, rfactor, rf4, rf5, rf6
  DOUBLE PRECISION :: dfdphid, PHASERHS_C_D
  INTEGER :: ii, jj
  DOUBLE PRECISION :: psirhs
  psirhs = 0.
  dfdphid = PHASERHS_C_D(phi, phid, c, cd, t, c_dot, phi_dot, vbles, &
&   vblesd, dx, dfdphi)
  IF (mode_1 .EQ. 1) THEN
    psirhs_d = dfdphid/dt
    psirhs = (dfdphi-unk_(2+2*nunkvbles))/dt
  ELSE IF (mode_1 .EQ. 2) THEN
    rfactor = dt/dtold
    rf4 = rfactor*rfactor/(rfactor+1.0)
    rf5 = rfactor + 1.0
    rf6 = (2.0*rfactor+1.0)/(rfactor+1.0)
    psirhs_d = rf6*dfdphid/dt
    psirhs = (rf6*dfdphi+rf4*unk_(5+2*nunkvbles)-rf5*unk_(4+2*nunkvbles)&
&     )/dt
  ELSE
    WRITE(*, *) 'mode_1 not = 1 or 2', mode_1
    STOP
  END IF
  psirhs_d = 1d-3*psirhs_d
  psirhs = psirhs*1d-3
END FUNCTION PSIRHS_D
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:54
!
!  Differentiation of soluterhs in forward (tangent) mode:
!   variations   of useful results: soluterhs
!   with respect to varying inputs: vbles
!
DOUBLE PRECISION FUNCTION SOLUTERHS_D(vbles, vblesd, dx, c_dot, phi_dot&
& , t, soluterhs)
! this uses volume element method. This guarantees conservation of solute. The main source of solute is the variation of free ene
!rgy with phase: d (d F/dc) = ...+ (d^2 F/dc d phi) d phi + ..., which is revealed by a plot of c_dot.
  USE SOLUTION_PARAMETERS
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: dx, c_dot, vbles(3, 3, 3), phi_dot, t
  DOUBLE PRECISION, INTENT(IN) :: vblesd(3, 3, 3)
  INTEGER :: ii, jj, ip, ih, jv
  DOUBLE PRECISION :: c, phi, psi, FREEENERGY, d, phi_, phi_tmp
  DOUBLE PRECISION :: cd, phid, psid, FREEENERGY_D, dd
  DOUBLE PRECISION, DIMENSION(3, 3), SAVE :: stencil11
  DOUBLE PRECISION, DIMENSION(3), SAVE :: stencil1=(/-.5, 0., .5/)
  DOUBLE PRECISION, DIMENSION(3), SAVE :: d1=(/6.70e-10, 6.70e-12, &
&   6.70e-12/)
  DOUBLE PRECISION :: dfdc, potential, lap_c, d_, d_c, d_cc, d_c1, d_cc1&
& , grad_c(2), y0, g_phi, F_C, F_CC
  DOUBLE PRECISION :: POTENTIAL_D, d_cd, d_ccd, G_PHI_D, F_C_D, F_CC_D
! (m^2/s)    characteristic diffusivity delta2/tau=M*eps2(1)
  DOUBLE PRECISION, SAVE :: d_ch=2.83e-10
  DOUBLE PRECISION :: beta1, beta2, m_tilde, phaserhs_c, ramp
  DOUBLE PRECISION :: beta1d, PHASERHS_C_D
  INTRINSIC RESHAPE
  REAL, DIMENSION(9) :: arg1
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: result2d
  DOUBLE PRECISION :: soluterhs

  arg1(:) = (/0., 6., 0., 6., -24., 6., 0., 6., 0./)
  stencil11 = RESHAPE(arg1(:), (/3, 3/))
  soluterhs = 0.
  d_ch = 2.83d-10
!if(df.eq.0)then
!x-coordinate transform values
!! Right
  ih = 3
  jv = 2
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  IF (beta .GT. 1d-6) THEN
    beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-&
&     vbles(1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd&
&     (1, 2, 2)+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, &
&     jv))**2-vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih&
&     , jv))
    beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&     vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  ELSE
    beta1d = 0.D0
  END IF
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  psid = vblesd(3, ih, jv)
  psi = vbles(3, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = d_cd*result1 + d_c*result1d + dd*c + d*cd + t*d_ccd
  soluterhs = soluterhs + d_c*result1 + d*c + d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d + 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs + d_c*0.34*beta1*psi*1d3
  END IF
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  psid = vblesd(3, 2, 2)
  psi = vbles(3, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d - d_cd*result1 - d_c*result1d - dd*c - d*cd &
&   - t*d_ccd
  soluterhs = soluterhs - d_c*result1 - d*c - d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d - 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs - d_c*0.34*beta1*psi*1d3
  END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!Left !
  ih = 1
  jv = 2
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  IF (beta .GT. 1d-6) THEN
    beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-&
&     vbles(1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd&
&     (1, 2, 2)+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, &
&     jv))**2-vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih&
&     , jv))
    beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&     vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  END IF
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  psid = vblesd(3, ih, jv)
  psi = vbles(3, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d + d_cd*result1 + d_c*result1d + dd*c + d*cd &
&   + t*d_ccd
  soluterhs = soluterhs + d_c*result1 + d*c + d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d + 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs + d_c*0.34*beta1*psi*1d3
  END IF
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  psid = vblesd(3, 2, 2)
  psi = vbles(3, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d - d_cd*result1 - d_c*result1d - dd*c - d*cd &
&   - t*d_ccd
  soluterhs = soluterhs - d_c*result1 - d*c - d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d - 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs - d_c*0.34*beta1*psi*1d3
  END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!up
  ih = 2
  jv = 3
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  IF (beta .GT. 1d-6) THEN
    beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-&
&     vbles(1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd&
&     (1, 2, 2)+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, &
&     jv))**2-vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih&
&     , jv))
    beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&     vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  END IF
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  psid = vblesd(3, ih, jv)
  psi = vbles(3, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d + d_cd*result1 + d_c*result1d + dd*c + d*cd &
&   + t*d_ccd
  soluterhs = soluterhs + d_c*result1 + d*c + d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d + 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs + d_c*0.34*beta1*psi*1d3
  END IF
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  psid = vblesd(3, 2, 2)
  psi = vbles(3, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d - d_cd*result1 - d_c*result1d - dd*c - d*cd &
&   - t*d_ccd
  soluterhs = soluterhs - d_c*result1 - d*c - d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d - 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs - d_c*0.34*beta1*psi*1d3
  END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!down
  ih = 2
  jv = 1
! The 0.34 = W/(R*T_melt*molpervol)=7e7/(8.31*456*54185)
  d = 0.
  d_c = 0.
  d_cc = 0.
  dd = 0.5*d1(1)*((1.+delta)*vblesd(1, ih, jv)+(1.+delta)*vblesd(1, 2, 2&
&   ))
  d = 0.5*d1(1)*((1.+delta)*vbles(1, ih, jv)+(1.+delta)*vbles(1, 2, 2))
  result1d = F_C_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_C_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_cd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d+&
&   vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_c = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  result1d = F_CC_D(vbles(2, ih, jv), vblesd(2, ih, jv), 0, result1)
  result2d = F_CC_D(vbles(2, 2, 2), vblesd(2, 2, 2), 0, result2)
  d_ccd = 0.5*d1(1)*(vblesd(1, ih, jv)*result1+vbles(1, ih, jv)*result1d&
&   +vblesd(1, 2, 2)*result2+vbles(1, 2, 2)*result2d)
  d_cc = 0.5*d1(1)*(vbles(1, ih, jv)*result1+vbles(1, 2, 2)*result2)
  IF (beta .GT. 1d-6) THEN
    beta1d = beta*lambda*8d0*(2*vbles(1, 2, 2)*vblesd(1, 2, 2)*(1d0-&
&     vbles(1, 2, 2))**2-vbles(1, 2, 2)**2*2*(1d0-vbles(1, 2, 2))*vblesd&
&     (1, 2, 2)+2*vbles(1, ih, jv)*vblesd(1, ih, jv)*(1d0-vbles(1, ih, &
&     jv))**2-vbles(1, ih, jv)**2*2*(1d0-vbles(1, ih, jv))*vblesd(1, ih&
&     , jv))
    beta1 = beta*lambda*8d0*(vbles(1, 2, 2)**2*(1d0-vbles(1, 2, 2))**2+&
&     vbles(1, ih, jv)**2*(1d0-vbles(1, ih, jv))**2)
  END IF
  cd = vblesd(2, ih, jv)
  c = vbles(2, ih, jv)
!  T= delta
  phid = vblesd(1, ih, jv)
  phi = vbles(1, ih, jv)
  psid = vblesd(3, ih, jv)
  psi = vbles(3, ih, jv)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d + d_cd*result1 + d_c*result1d + dd*c + d*cd &
&   + t*d_ccd
  soluterhs = soluterhs + d_c*result1 + d*c + d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d + 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs + d_c*0.34*beta1*psi*1d3
  END IF
!  centre
  cd = vblesd(2, 2, 2)
  c = vbles(2, 2, 2)
  phid = vblesd(1, 2, 2)
  phi = vbles(1, 2, 2)
  psid = vblesd(3, 2, 2)
  psi = vbles(3, 2, 2)
  result1d = FREEENERGY_D(c, cd, t, phi, phid, c_dot, phi_dot, 2, &
&   result1)
  soluterhs_d = soluterhs_d - d_cd*result1 - d_c*result1d - dd*c - d*cd &
&   - t*d_ccd
  soluterhs = soluterhs - d_c*result1 - d*c - d_cc*t
  IF (beta .GT. 1d-6) THEN
    soluterhs_d = soluterhs_d - 0.34*1d3*((d_cd*beta1+d_c*beta1d)*psi+&
&     d_c*beta1*psid)
    soluterhs = soluterhs - d_c*0.34*beta1*psi*1d3
  END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  soluterhs_d = soluterhs_d/d_ch/(dx*dx)
  soluterhs = soluterhs/d_ch/(dx*dx)
END FUNCTION SOLUTERHS_D
